<h1>דוח מסכם - פרויקט TCP/IP</h1>
<p style="text-align: center; font-size: 13pt; margin: 0 0 12px 0; padding: 0; font-weight: normal;">פרויקט מסכם בקורס תקשורת מחשבים</p>
<p style="text-align: center; font-size: 12pt; margin: 0 0 30px 0; padding: 0; font-weight: normal;"><strong>מגישים:</strong> יניב בהלול, בן פרידמן</p>

<div class="abstract">
<h3 style="margin-top: 0; padding-top: 0; margin-bottom: 10px;">תקציר</h3>
<p style="text-indent: 0; margin-top: 0;">
פרויקט זה מציג יישום מלא של תקשורת TCP/IP שפותח בשני חלקים עיקריים: חלק ראשון עוסק בהדמיית תהליך האריזה (Encapsulation) 
של חבילות נתונים בשכבות מודל TCP/IP ולכידת התעבורה ב-Wireshark, וחלק שני מציג פיתוח מעשי של שרת ולקוח עם תכנות אסינכרוני, 
ממשק גרפי, וניתוח תעבורה עד שכבת הרשת.
</p>
</div>

<h2>1. חלק 1: אריזה ולכידת המנות</h2>

<h3>1.1 דרך יצירת קובץ CSV עם הודעות בשכבת היישום</h3>

<p>
קובץ ה-CSV <code>group68_http_input.csv</code> נוצר כקובץ קלט המכיל 89 הודעות HTTP המדמות תעבורת אינטרנט אמיתית. 
הקובץ מאורגן במבנה טבלאי עם העמודות הבאות:
</p>

<table>
    <tr>
        <th>עמודה</th>
        <th>תיאור</th>
        <th>דוגמה</th>
    </tr>
    <tr>
        <td>msg_id</td>
        <td>מזהה ייחודי עוקב לכל הודעה</td>
        <td>1, 2, 3, ...</td>
    </tr>
    <tr>
        <td>app_protocol</td>
        <td>פרוטוקול שכבת היישום</td>
        <td>HTTP</td>
    </tr>
    <tr>
        <td>src_app / dst_app</td>
        <td>יישום מקור/יעד</td>
        <td>client_browser, web_server</td>
    </tr>
    <tr>
        <td>src_port / dst_port</td>
        <td>פורט מקור/יעד</td>
        <td>54321, 80</td>
    </tr>
    <tr>
        <td>message</td>
        <td>תוכן ההודעה (HTTP request/response)</td>
        <td>GET /index.html HTTP/1.1</td>
    </tr>
    <tr>
        <td>timestamp</td>
        <td>חותמת זמן (שניות מהתחלה)</td>
        <td>0.005, 0.012, 0.025...</td>
    </tr>
</table>

<p>
הקובץ מכיל הודעות HTTP מגוונות הממדמות גלישה באתר אינטרנט: <strong>בקשות GET</strong> כוללות דפי HTML (index.html), קבצי CSS (styles.css), JavaScript (app.js), תמונות (logo.png), fonts (roboto.woff2), ו-favicon.ico. <strong>בקשות POST</strong> מייצגות פעולות אינטראקטיביות כמו התחברות (api/login) ושליחת לוגים (api/logs). <strong>תגובות השרת</strong> כוללות קודי סטטוס שונים: 200 OK (הצלחה), 404 Not Found (קובץ לא נמצא), ו-201 Created (נוצר בהצלחה).
</p>

<p>
הקובץ נוצר בפורמט CSV סטנדרטי עם קידוד UTF-8, ומשמש כקלט להדמיית תהליך האריזה ולשליחת תעבורה לשרת לצורך לכידה ב-Wireshark.
</p>

<h3>1.2 תיאור והסבר של תהליך אריזה של מנות</h3>

<p>
תהליך האריזה (Encapsulation) הוא תהליך מרכזי במודל TCP/IP, בו כל שכבה "עוטפת" את הנתונים מהשכבה שמעליה במידע נוסף (header) הנדרש להעברה ברשת. 
בפרויקט זה, יישמנו פונקציה <code>simulate_encapsulation()</code> המדמה את התהליך המלא.
</p>

<h4>אלגוריתם האריזה:</h4>

<p>
הפונקציה מקבלת שורה מהקובץ CSV ומבצעת אריזה בשכבות הבאות, מלמעלה למטה:
</p>

<p>
<strong>שכבת היישום (Application Layer):</strong> הפונקציה לוקחת את תוכן ההודעה מה-CSV (HTTP request/response) ויוצרת מבנה dictionary עם פרוטוקול HTTP ו-payload (תוכן ההודעה).
</p>

<p>
<strong>שכבת התעבורה (Transport Layer - TCP):</strong> הפונקציה מגדירה פרוטוקול TCP, יוצרת פורט מקור אקראי בטווח 1024-65535 ופורט יעד 10000, יוצרת מספר רצף (seq_num) ומספר אישור (ack_num) אקראיים, ומגדירה דגלי TCP: PSH, ACK.
</p>

<p>
<strong>שכבת הרשת (Network Layer - IP):</strong> הפונקציה מגדירה פרוטוקול IPv4, מגדירה כתובת IP מקור (src_ip: 192.168.0.65) ויעד (dst_ip: 192.168.0.106), ומגדירה TTL=64 (Time To Live).
</p>

<p>
<strong>שכבת הקו (Link Layer - Ethernet):</strong> הפונקציה מגדירה כתובת MAC מקור (src_mac) ויעד (dst_mac), ומגדירה סוג Ethernet II.
</p>

<h4>מבנה החבילה:</h4>

<p>
כל חבילה מכילה את כל השכבות במבנה היררכי:
</p>

<pre>
{
    "msg_id": 1,
    "timestamp": 0.005,
    "application": {
        "protocol": "HTTP",
        "payload": "GET /index.html HTTP/1.1"
    },
    "transport": {
        "protocol": "TCP",
        "src_port": 64401,
        "dst_port": 10000,
        "seq_num": 1234,
        "ack_num": 5678,
        "flags": "PSH, ACK"
    },
    "network": {
        "protocol": "IPv4",
        "src_ip": "192.168.0.65",
        "dst_ip": "192.168.0.106",
        "ttl": 64
    },
    "link": {
        "src_mac": "AA:BB:CC:DD:EE:01",
        "dst_mac": "AA:BB:CC:DD:EE:02",
        "type": "Ethernet II"
    }
}
</pre>

<p>
תהליך האריזה מדגים כיצד כל שכבה מוסיפה overhead (TCP ~20 בתים, IP ~20 בתים, Ethernet ~14 בתים), 
מה שמסביר את המחיר של הארגון ההיררכי ואת החשיבות של פרוטוקולים יעילים כמו HTTP/2.
</p>

<h3>1.3 תיאור והסבר של תהליך הלכידה</h3>

<p>
תהליך הלכידה של התעבורה ב-Wireshark כלל מספר שלבים:
</p>

<h4>הכנה ולכידה:</h4>

<p>
תהליך הלכידה מתחיל בהכנת סביבת העבודה: הרצת שרת TCP בפורט 10000 ופתיחת Jupyter Notebook עם הפונקציה <code>send_http_traffic()</code>.
</p>

<p>
בשלב הגדרת Wireshark, יש לפתוח את Wireshark ולבחור את ממשק הרשת המתאים (Wi-Fi/Ethernet), להגדיר פילטר <code>tcp.port == 10000</code> או <code>ip.addr == 192.168.0.106</code>, ולהתחיל לכידה (Start Capture).
</p>

<p>
שליחת התעבורה מתבצעת על ידי הרצת הפונקציה <code>send_http_traffic(df)</code> מה-notebook. הפונקציה קוראת את קובץ ה-CSV ושולחת כל הודעה HTTP לשרת, עם delay של 0.3 שניות בין כל הודעה. כל הודעה נשלחת בחיבור TCP נפרד (socket חדש לכל הודעה).
</p>

<p>
בסיום התהליך, יש להמתין לסיום שליחת כל ההודעות, לעצור את הלכידה ב-Wireshark, ולשמור את הקובץ בשם <code>the_output.pcapng</code>.
</p>

<h4>פונקציית שליחת התעבורה:</h4>

<p>
הפונקציה <code>send_http_traffic()</code> מיישמת את השליחה באופן הבא: היא קוראת את קובץ ה-CSV עם pandas, עוברת על כל שורה ושולחת את ההודעה HTTP לשרת. עבור כל הודעה, הפונקציה יוצרת socket חדש (IPv4, TCP), מתחברת לשרת ב-192.168.0.106:10000, שולחת את ההודעה עם <code>sendall()</code>, מקבלת תגובה קצרה מהשרת, סוגרת את החיבור, וממתינה delay לפני ההודעה הבאה.
</p>

<p>
הגישה של חיבור נפרד לכל הודעה מדמה מצב של HTTP/1.0 (Connection: close), 
שבו כל בקשה נדרשת חיבור חדש.
</p>

<h3>1.4 תיאור והסבר של תעבורה שנלכדה ב-Wireshark כולל צילומי מסך</h3>

<p>
לאחר לכידת התעבורה ב-Wireshark, נלכדו חבילות נתונים רבות המציגות את כל שלבי התקשורת TCP/IP. 
ניתוח הקובץ <code>the_output.pcapng</code> מראה את הדפוסים הבאים:
</p>

<h4>ניתוח תעבורה - דפוסים עיקריים:</h4>

<p>
התעבורה שנלכדה מציגה מספר דפוסים עיקריים:
</p>

<ol>
    <li><strong>TCP Handshake (SYN, SYN-ACK, ACK):</strong>
        <p>
        כל חיבור מתחיל בשלושה-שלבים:
        </p>
        <ul>
            <li>הלקוח שולח SYN (מספר 2821: 64401 → 10000 [SYN])</li>
            <li>השרת משיב SYN-ACK (מספר 2835: 10000 → 64401 [SYN, ACK])</li>
            <li>הלקוח משלח ACK (מספר 2837: 64401 → 10000 [ACK])</li>
        </ul>
    </li>
    <li><strong>העברת נתונים (HTTP):</strong>
        <p>
        לאחר ה-handshake, נשלחות בקשות HTTP:
        </p>
        <ul>
            <li>בקשות GET: GET /index.html HTTP/1.1, GET /css/styles.css HTTP/1.1, GET /js/app.js HTTP/1.1</li>
            <li>בקשות POST: POST /api/login HTTP/1.1</li>
            <li>תגובות שרת: HTTP/1.1 200 OK, HTTP/1.1 404 Not Found, HTTP/1.1 201 Created</li>
        </ul>
        <p>
        ההודעות נשלחות עם דגלי TCP PSH+ACK, המציינים שהנתונים צריכים להישלח מיידית לשכבת היישום.
        </p>
    </li>
    <li><strong>סגירת חיבור (FIN, FIN-ACK, RST):</strong>
        <p>
        ניתן לראות שתי דפוסים של סגירה:
        </p>
        <ul>
            <li><strong>סגירה מסודרת (FIN, FIN-ACK, ACK):</strong> בחלק מהחיבורים</li>
            <li><strong>סגירה בוטה (RST, ACK):</strong> בחלק מהחיבורים, מה שמעיד על סגירה מהירה של החיבור</li>
        </ul>
    </li>
</ol>

<h4>דוגמאות ספציפיות מהתעבורה שנלכדה:</h4>

<p>
להלן דוגמאות מהתעבורה שנלכדה:
</p>

<div class="network-table">
<pre>
2821  8.698933  192.168.0.65 → 192.168.0.106  TCP  66  64401 → 10000 [SYN] Seq=0 Win=65535
2835  8.773528  192.168.0.106 → 192.168.0.65  TCP  66  10000 → 64401 [SYN, ACK] Seq=0 Ack=1
2837  8.773650  192.168.0.65 → 192.168.0.106  TCP  54  64401 → 10000 [ACK] Seq=1 Ack=1
2839  8.773698  192.168.0.65 → 192.168.0.106  HTTP 122  GET /index.html HTTP/1.1
2840  8.778262  192.168.0.106 → 192.168.0.65  TCP  54  10000 → 64401 [ACK] Seq=1 Ack=69
2841  8.778949  192.168.0.106 → 192.168.0.65  TCP  61  10000 → 64401 [PSH, ACK] Seq=1 Ack=69 Len=7
2844  8.783459  192.168.0.106 → 192.168.0.65  HTTP 138  Continuation (תגובת שרת)
2842  8.779040  192.168.0.65 → 192.168.0.106  TCP  54  64401 → 10000 [FIN, ACK] Seq=69 Ack=8
2845  8.783512  192.168.0.65 → 192.168.0.106  TCP  54  64401 → 10000 [RST, ACK] Seq=70 Ack=92
</pre>
</div>

<h4>ניתוח שכבות:</h4>

<p>
ב-Wireshark ניתן לראות את כל שכבות המודל TCP/IP. <strong>Frame (שכבת פיזית)</strong> מכיל מידע על החבילה (מספר, זמן, גודל). <strong>Ethernet II (שכבת קו)</strong> מכיל כתובות MAC וסוג פרוטוקול. <strong>Internet Protocol Version 4 (שכבת רשת)</strong> מכיל כתובות IP (src=192.168.0.65, dst=192.168.0.106), TTL=64, ו-Protocol: TCP (6).
</p>

<p>
<strong>Transmission Control Protocol (שכבת תעבורה)</strong> מכיל פורטים (src_port: 64401-64421, dst_port: 10000), מספרי רצף ואישור, דגלים (SYN, ACK, FIN, RST, PSH), וגודל חלון (Window Size). <strong>Hypertext Transfer Protocol (שכבת יישום)</strong> מכיל בקשות HTTP (GET, POST), תגובות HTTP (200 OK, 404 Not Found, 201 Created), ו-Headers (Host, Connection).
</p>

<h4>תובנות מהניתוח:</h4>

<p>
התעבורה מציגה מספר תובנות: כל הודעה נשלחת בחיבור נפרד (64401-64421), מה שמדגים את המחיר של HTTP/1.0. חלק מהחיבורים מסתיימים עם RST במקום FIN, מה שמעיד על סגירה מהירה. הזמנים בין ההודעות תואמים ל-delay של 0.3 שניות שהוגדר בקוד. חבילות HTTP קטנות יחסית (54-142 בתים), מה שמתאים לבקשות ותגובות קצרות.
</p>

<h4>צילומי מסך מ-Wireshark:</h4>

<p>
להלן צילומי מסך מהתעבורה שנלכדה ב-Wireshark:
</p>

<h5>צילום מסך 1: Follow TCP Stream - תוכן ההודעה</h5>

<p>
<img src="img/wireshark_tcp_stream.png" alt="Follow TCP Stream - תוכן ההודעה HTTP">
</p>

<p>
הצילום הראשון מציג את התוצאה של "Follow TCP Stream" עבור stream מספר 15. 
זה מציג את תוכן ההודעה המלא בין הלקוח לשרת:
</p>

<p>
<strong>בקשה מהלקוח (אדום):</strong> <code>GET /index.html HTTP/1.1</code> - בקשה HTTP לקבל את הקובץ index.html, <code>Host: 192.168.0.106</code> - כתובת השרת, <code>Connection: close</code> - בקשה לסגור את החיבור לאחר התגובה.
</p>

<p>
<strong>תגובה מהשרת (כחול):</strong> <code>welcomeserver received GET /INDEX.HTML HTTP/1.1</code> - אישור שהשרת קיבל את הבקשה, <code>HOST: 192.168.0.106</code> - כתובת השרת, <code>CONNECTION: CLOSE</code> - הסכמה לסגור את החיבור.
</p>

<p>
בתחתית החלון ניתן לראות סטטיסטיקות:
</p>

<p>
בתחתית החלון מוצגות הסטטיסטיקות: 1 client pkt(s), 2 server pkt(s), 1 turn(s) - כלומר 1 חבילה מהלקוח, 2 חבילות מהשרת, 1 מחזור (request-response). Stream: 15 הוא מספר הזרם, התוכן מוצג בפורמט ASCII, וגודל כל השיחה (Entire conversation) הוא 159 בתים.
</p>

<p>
צילום זה מדגים את תוכן ההודעות בפועל - בקשות HTTP ותגובות השרת, 
מעבר לפרטים הטכניים של החבילות.
</p>

<h5>צילום מסך 2: פירוט חבילה בודדת - חבילה 2835</h5>

<p>
<img src="img/wireshark_packet_details.png" alt="פירוט חבילה בודדת ב-Wireshark - חבילה 2835 SYN-ACK">
</p>

<p>
הצילום השני מציג פירוט מלא של חבילה בודדת (חבילה 2835) - חבילת SYN-ACK מהשרת ללקוח.
החלון מחולק לשלושה חלקים:
</p>

<ol>
    <li><strong>חלק עליון (רשימת חבילות - חלקי):</strong> מציג חלק מרשימת החבילות, עם חבילה 2835 מסומנת</li>
    <li><strong>חלק אמצעי (פירוט החבילה):</strong> מציג את כל שכבות המודל TCP/IP:
        <ul>
            <li><strong>Frame (שכבת פיזית):</strong>
                <ul>
                    <li>גודל: 528 ביטים (66 בתים)</li>
                    <li>ממשק: Wi-Fi 2</li>
                </ul>
            </li>
            <li><strong>Ethernet II (שכבת קו):</strong>
                <ul>
                    <li>Source MAC: 5e:6d:59:f3:7d:b8</li>
                    <li>Destination MAC: 58:a0:23:44:8e:f0 (Intel)</li>
                </ul>
            </li>
            <li><strong>Internet Protocol Version 4 (שכבת רשת):</strong>
                <ul>
                    <li>Source IP: 192.168.0.106 (השרת)</li>
                    <li>Destination IP: 192.168.0.65 (הלקוח)</li>
                </ul>
            </li>
            <li><strong>Transmission Control Protocol (שכבת תעבורה):</strong>
                <ul>
                    <li>Source Port: 10000 (פורט השרת)</li>
                    <li>Destination Port: 64401 (פורט הלקוח)</li>
                    <li>Sequence Number: 0</li>
                    <li>Acknowledgment Number: 1</li>
                    <li>Flags: [SYN, ACK] - תגובת השרת לבקשת החיבור</li>
                    <li>Window Size: 65535</li>
                    <li>Maximum Segment Size (MSS): 1460</li>
                    <li>Window Scale (WS): 64</li>
                    <li>SACK_PERM - Selective Acknowledgment Permitted</li>
                </ul>
            </li>
        </ul>
    </li>
    <li><strong>חלק תחתון (קוד החבילה):</strong> מציג את הנתונים הגולמיים של החבילה בפורמט hexadecimal משמאל ו-ASCII מימין</li>
</ol>

<p>
צילום זה מדגים את מבנה החבילה המלא - איך כל שכבה "עוטפת" את הנתונים מהשכבה שמעליה, 
משכבת היישום (HTTP) ועד שכבת הקו (Ethernet). ניתן לראות את כל ה-headers של כל שכבה, 
את הדגלים, המספרים, והפרמטרים הטכניים.
</p>

<p>
חבילה זו היא חלק מ-TCP handshake - זהו ה-SYN-ACK שהשרת שולח ללקוח לאחר שהלקוח שלח SYN, 
כחלק משלושת שלבי ה-handshake (SYN → SYN-ACK → ACK).
</p>

<h2>2. חלק 2: יצירת יישום וניתוח תעבורה</h2>

<h3>2.1 הסבר כללי על מערכת ומבנה הקוד</h3>

<h4>ארכיטקטורה כללית:</h4>

<p>
הפרויקט מחולק לשלושה חלקים עיקריים. <strong>גרסאות סינכרוניות (server.py, client.py)</strong> כוללות שרת multi-threading קלאסי ולקוח סינכרוני פשוט, המשמשים כבסיס להבנת העקרונות. <strong>גרסאות אסינכרוניות (async_impl/)</strong> כוללות <code>server_async.py</code> (שרת אסינכרוני מבוסס asyncio), <code>client_async.py</code> (לקוח אסינכרוני), ו-<code>client_chat.py</code> (לקוח צ'אט מתקדם), המציעים יעילות גבוהה יותר לטיפול בחיבורים מרובים. <strong>ממשקים גרפיים (gui/)</strong> כוללים <code>server_gui.py</code> (ממשק גרפי לניהול שרת) ו-<code>client_gui.py</code> (ממשק גרפי ללקוח), המבוססים על tkinter.
</p>

<p>
<strong>תיקיות וקבצים נוספים:</strong> התיקייה <code>utils/</code> מכילה את <code>config.py</code> (מערכת ניהול הגדרות מרכזית), <code>config.json</code> (קובץ הגדרות), ו-<code>logger.py</code> (מערכת לוגים מקצועית).
</p>

<h4>זרימת נתונים:</h4>

<p>
הלקוח קורא קובץ CSV עם הודעות HTTP ומתחבר לשרת (TCP handshake). השרת שולח הודעת ברכה, והלקוח שולח הודעות HTTP אחת אחרי השנייה. השרת מקבל כל הודעה, מעבד אותה, ושולח תגובה. כל הודעה נרשמת ב-log עם timestamp, והחיבור נסגר לאחר סיום.
</p>

<h3>2.2 הוראות התקנה והרצה</h3>

<h4>דרישות מערכת:</h4>

<p>
הפרויקט דורש Python 3.7 או גרסה חדשה יותר, pip (מנהל חבילות Python), ו-Wireshark (לחלק 1 - לכידת תעבורה).
</p>

<h4>התקנה:</h4>

<ol>
    <li><strong>שכפול/הורדת הפרויקט:</strong>
        <pre>cd /path/to/projectHIT</pre>
    </li>
    <li><strong>התקנת תלויות:</strong>
        <pre>cd prt2
pip install -r requirements.txt</pre>
        <p>
        קובץ requirements.txt מכיל את החבילות הבאות: pandas (לניתוח CSV), asyncio (כבר מובנה ב-Python 3.7+), tkinter (כבר מובנה ב-Python, בדרך כלל), ו-matplotlib (לגרפים ב-GUI).
        </p>
    </li>
</ol>

<h4>הרצה:</h4>

<p><strong>גרסה סינכרונית בסיסית:</strong></p>

<ol>
    <li><strong>הרצת שרת:</strong>
        <pre>cd prt2
python server.py</pre>
        <p>השרת יתחיל להאזין על 0.0.0.0:10000</p>
    </li>
    <li><strong>הרצת לקוח (בטרמינל אחר):</strong>
        <pre>cd prt2
python client.py</pre>
        <p>הלקוח יתחבר לשרת וישלח את כל ההודעות מה-CSV</p>
    </li>
</ol>

<p><strong>גרסה אסינכרונית:</strong></p>

<ol>
    <li><strong>הרצת שרת:</strong>
        <pre>cd prt2
python async_impl/server_async.py</pre>
    </li>
    <li><strong>הרצת לקוח:</strong>
        <pre>cd prt2
python async_impl/client_async.py</pre>
    </li>
</ol>

<p><strong>ממשקים גרפיים (GUI):</strong></p>

<ol>
    <li><strong>הרצת שרת GUI:</strong>
        <pre>cd prt2
python gui/server_gui.py</pre>
        <p>
        הממשק כולל הגדרות (Host, Port), כפתורי Start/Stop, סטטיסטיקות בזמן אמת, רשימת לקוחות מחוברים, לוגים, ואפשרות ייצוא נתונים.
        </p>
    </li>
    <li><strong>הרצת לקוח GUI:</strong>
        <pre>cd prt2
python gui/client_gui.py</pre>
        <p>
        הממשק כולל הגדרות חיבור, בחירת קובץ CSV ושליחה, שליחת הודעה יחידה, וטאבים: Messages, Statistics, Graphs.
        </p>
    </li>
</ol>

<h3>2.3 דוגמאות קלט ופלט</h3>

<h4>פלט - GUI:</h4>

<h5>ניתוח תעבורה - הקמת חיבור TCP:</h5>

<p>
להלן ניתוח של תעבורה שנלכדה ב-Wireshark המראה את תהליך הקמת החיבור (TCP three-way handshake) והעברת הנתונים הראשונית:
</p>

<p>
<img src="img/first_connection.png" alt="תמונת Wireshark - הקמת חיבור TCP עם SYN, SYN-ACK, ACK">
</p>

<p>
התמונה מציגה את שלבי הקמת החיבור TCP בין הלקוח (192.168.0.65) לשרת (192.168.0.106) על פורט 10000:
</p>

<div class="network-table">
<pre>
1699  12.927193  192.168.0.65 → 192.168.0.106  TCP  66  62263 → 10000 [SYN] Seq=0 Win=65535 Len=0 MSS=1460 WS=256 SACK_PERM
1712  13.024601  192.168.0.106 → 192.168.0.65  TCP  66  10000 → 62263 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=1460 WS=64 SACK_PERM
1713  13.024672  192.168.0.65 → 192.168.0.106  TCP  54  62263 → 10000 [ACK] Seq=1 Ack=1 Win=65280 Len=0
1715  13.029840  192.168.0.106 → 192.168.0.65  TCP  54  [TCP Window Update] 10000 → 62263 [ACK] Seq=1 Ack=1 Win=262144 Len=0
1716  13.029840  192.168.0.106 → 192.168.0.65  TCP  85  10000 → 62263 [PSH, ACK] Seq=1 Ack=1 Win=262144 Len=31
1717  13.030599  192.168.0.65 → 192.168.0.106  TCP  60  62263 → 10000 [PSH, ACK] Seq=1 Ack=32 Win=65280 Len=6
1718  13.034380  192.168.0.106 → 192.168.0.65  TCP  54  10000 → 62263 [ACK] Seq=32 Ack=7 Win=262144 Len=0
1719  13.039021  192.168.0.106 → 192.168.0.65  TCP  151  10000 → 62263 [PSH, ACK] Seq=32 Ack=7 Win=262144 Len=97
1735  13.091989  192.168.0.65 → 192.168.0.106  TCP  54  62263 → 10000 [ACK] Seq=7 Ack=129 Win=65280 Len=0
</pre>
</div>

<p>
<strong>ניתוח תהליך ה-handshake:</strong>
</p>

<p>
<strong>חבילה 1699 - SYN:</strong> הלקוח (192.168.0.65:62263) שולח SYN לשרת (192.168.0.106:10000) עם Seq=0, Win=65535 (גודל חלון ראשוני), MSS=1460 (Maximum Segment Size), WS=256 (Window Scale), SACK_PERM (Selective Acknowledgment), בגודל 66 בתים.
</p>

<p>
<strong>חבילה 1712 - SYN-ACK:</strong> השרת משיב עם SYN-ACK - מקבל את ה-SYN ושולח SYN משלו, עם Seq=0, Ack=1 (מאשר את ה-SYN של הלקוח), Win=65535, MSS=1460, WS=64, SACK_PERM, בגודל 66 בתים.
</p>

<p>
<strong>חבילה 1713 - ACK:</strong> הלקוח משלח ACK - מאשר את ה-SYN-ACK של השרת, עם Seq=1, Ack=1, Win=65280 (חלון מעודכן). החיבור מוכן - ה-handshake הושלם. גודל החבילה: 54 בתים.
</p>

<p>
<strong>העברת נתונים לאחר ה-handshake:</strong> לאחר השלמת ה-handshake, השרת שולח חבילת TCP Window Update (חבילה 1715) המעדכנת את גודל החלון ל-Win=262144, מה שמציין שינוי בגודל החלון של המקלט. חבילות PSH+ACK מכילות את הנתונים בפועל: חבילה 1716 מכילה 31 בתים מהשרת, חבילה 1717 מכילה 6 בתים מהלקוח, וחבילה 1719 מכילה 97 בתים מהשרת. חבילות ACK הן חבילות אישור ללא נתונים (Len=0) בגודל 54 בתים, המאשרות קבלה של הנתונים שנשלחו.
</p>

<p>
<strong>תמונת Follow TCP Stream:</strong>
</p>

<p>
<img src="img/follow tcp stream.png" alt="Wireshark Follow TCP Stream - תוכן השיחה בין הלקוחות">
</p>

<p>
התמונה מציגה את תוכן השיחה ברמת שכבת היישום, כפי שמוצג ב-Wireshark "Follow TCP Stream". 
ניתן לראות את ההודעות המלאות שהחליפו הלקוחות, כולל הודעות ברכה, שאלות, ותגובות.
</p>

<p>
<strong>תמונת פירוט חבילה בודדת:</strong>
</p>

<p>
<img src="img/onepacket.png" alt="Wireshark - פירוט חבילה בודדת מספר 4685">
</p>

<p>
התמונה מציגה פירוט מלא של חבילה בודדת (חבילה 4685), כולל את כל שכבות המודל TCP/IP: <strong>Ethernet II (שכבת קו)</strong> עם כתובות MAC (Source: Intel_44:8e:f0, Destination: 5e:6d:59:f3:7d:b8), <strong>IPv4 (שכבת רשת)</strong> עם כתובות IP (Source: 192.168.0.65, Destination: 192.168.0.106), <strong>TCP (שכבת תעבורה)</strong> עם פורטים (62150 → 10000), מספרי רצף (Seq=42, Ack=88), דגלים (PSH, ACK), וגודל נתונים (Len=40), ו-<strong>Data (שכבת יישום)</strong> עם 40 בתים של נתונים בפורמט hexadecimal ו-ASCII.
</p>

<h5>ניתוח תעבורה - סיום חיבור TCP:</h5>

<p>
להלן ניתוח של תעבורה שנלכדה ב-Wireshark המראה את תהליך סיום החיבור (TCP connection termination):
</p>

<p>
<img src="img/end_connection.png" alt="תמונת Wireshark - סיום חיבור TCP עם FIN, ACK">
</p>

<p>
התמונה מציגה את תחילת תהליך סיום החיבור TCP בין השרת (192.168.0.106) ללקוח (192.168.0.65) על פורט 10000:
</p>

<div class="network-table">
<pre>
9536  127.760203  192.168.0.106 → 192.168.0.65  TCP  54  10000 → 62263 [FIN, ACK] Seq=129 Ack=7 Win=262144 Len=0
9537  127.760245  192.168.0.65 → 192.168.0.106  TCP  54  62263 → 10000 [ACK] Seq=7 Ack=130 Win=65280 Len=0
</pre>
</div>

<p>
<strong>ניתוח תהליך סיום החיבור:</strong>
</p>

<p>
<strong>חבילה 9536 - FIN, ACK:</strong> השרת (192.168.0.106:10000) שולח FIN, ACK ללקוח (192.168.0.65:62263). דגל FIN מציין שהשרת רוצה לסגור את החיבור. החבילה מכילה Seq=129, Ack=7, Win=262144, ו-Len=0 - אין נתונים בחבילה זו, רק דגל FIN. גודל החבילה: 54 בתים (TCP header בלבד).
</p>

<p>
<strong>חבילה 9537 - ACK:</strong> הלקוח משיב עם ACK - מאשר את ה-FIN של השרת. החבילה מכילה Seq=7, Ack=130 (Seq 129 + Len 0 + 1 עבור FIN = 130), Win=65280, ו-Len=0 - אישור בלבד, אין נתונים. גודל החבילה: 54 בתים.
</p>

<p>
<strong>הערות חשובות:</strong>
</p>

<p>
<strong>TCP Four-Way Handshake:</strong> סיום חיבור TCP מלא הוא תהליך בן ארבעה שלבים (four-way handshake). התעבורה כאן מציגה את שני השלבים הראשונים: FIN, ACK מהשרת, ו-ACK מהלקוח. לסיום מלא, נדרשים גם FIN, ACK מהלקוח ו-ACK מהשרת.
</p>

<p>
<strong>Half-Close:</strong> לאחר ה-FIN, ACK מהשרת וה-ACK מהלקוח, החיבור נמצא במצב "half-close". השרת כבר סגר את כיוון השליחה שלו, אך עדיין יכול לקבל נתונים מהלקוח. החיבור ייסגר לחלוטין רק לאחר שה-FIN השני (מהלקוח) והאישור שלו יישלחו.
</p>

<p>
<strong>מספרי רצף:</strong> מספר האישור (Ack) בחבילה 9537 הוא 130, שהוא Seq של החבילה הקודמת (129) + 1, מה שמאשר את קבלת ה-FIN מהשרת.
</p>

<p>
<strong>מחזור חיים מלא של חיבור TCP:</strong>
</p>

<p>
עכשיו יש לנו דוגמאות מלאות לכל שלבי מחזור החיים של חיבור TCP:
</p>

<ol>
    <li><strong>הקמת חיבור (Connection Establishment):</strong> SYN → SYN-ACK → ACK (three-way handshake)</li>
    <li><strong>העברת נתונים (Data Transfer):</strong> PSH+ACK, ACK - העברת הודעות ונתונים</li>
    <li><strong>סיום חיבור (Connection Termination):</strong> FIN, ACK → ACK → FIN, ACK → ACK (four-way handshake)</li>
</ol>

<h5>ניתוח תעבורה - שיחה במהלך חיבור קיים:</h5>

<p>
להלן ניתוח של תעבורה שנלכדה ב-Wireshark במהלך שיחה בין לקוחות, כאשר הלכידה החלה <strong>לאחר שהחיבור TCP כבר הוקם</strong>:
</p>

<div class="network-table">
<pre>
766   5.024819   192.168.0.65 → 192.168.0.106  TCP  58  62150 → 10000 [PSH, ACK] Seq=1 Ack=1 Win=254 Len=4
771   5.068332   192.168.0.106 → 192.168.0.65  TCP  54  10000 → 62150 [ACK] Seq=1 Ack=5 Win=4096 Len=0
950   9.626687   192.168.0.106 → 192.168.0.65  TCP  67  10000 → 62150 [PSH, ACK] Seq=1 Ack=5 Win=4096 Len=13
957   9.670864   192.168.0.65 → 192.168.0.106  TCP  54  62150 → 10000 [ACK] Seq=5 Ack=14 Win=254 Len=0
1272  15.392085  192.168.0.65 → 192.168.0.106  TCP  67  62150 → 10000 [PSH, ACK] Seq=5 Ack=14 Win=254 Len=13
1279  15.410709  192.168.0.106 → 192.168.0.65  TCP  54  10000 → 62150 [ACK] Seq=14 Ack=18 Win=4096 Len=0
1426  21.981069  192.168.0.106 → 192.168.0.65  TCP  91  10000 → 62150 [PSH, ACK] Seq=14 Ack=18 Win=4096 Len=37
1437  22.032631  192.168.0.65 → 192.168.0.106  TCP  54  62150 → 10000 [ACK] Seq=18 Ack=51 Win=254 Len=0
1821  29.029228  192.168.0.65 → 192.168.0.106  TCP  59  62150 → 10000 [PSH, ACK] Seq=18 Ack=51 Win=254 Len=5
1834  29.139037  192.168.0.106 → 192.168.0.65  TCP  54  10000 → 62150 [ACK] Seq=51 Ack=23 Win=4096 Len=0
2117  34.478204  192.168.0.65 → 192.168.0.106  TCP  73  62150 → 10000 [PSH, ACK] Seq=23 Ack=51 Win=254 Len=19
2129  34.565426  192.168.0.106 → 192.168.0.65  TCP  54  10000 → 62150 [ACK] Seq=51 Ack=42 Win=4096 Len=0
2345  49.441635  192.168.0.106 → 192.168.0.65  TCP  91  10000 → 62150 [PSH, ACK] Seq=51 Ack=42 Win=4096 Len=37
2354  49.485992  192.168.0.65 → 192.168.0.106  TCP  54  62150 → 10000 [ACK] Seq=42 Ack=88 Win=254 Len=0
4685  79.650665  192.168.0.65 → 192.168.0.106  TCP  94  62150 → 10000 [PSH, ACK] Seq=42 Ack=88 Win=254 Len=40
4698  79.724048  192.168.0.106 → 192.168.0.65  TCP  54  10000 → 62150 [ACK] Seq=88 Ack=82 Win=4096 Len=0
4884  100.497716  192.168.0.106 → 192.168.0.65  TCP  80  10000 → 62150 [PSH, ACK] Seq=88 Ack=82 Win=4096 Len=26
4895  100.541178  192.168.0.65 → 192.168.0.106  TCP  54  62150 → 10000 [ACK] Seq=82 Ack=114 Win=254 Len=0
5149  108.162368  192.168.0.106 → 192.168.0.65  TCP  66  10000 → 62150 [PSH, ACK] Seq=114 Ack=82 Win=4096 Len=12
5158  108.206980  192.168.0.65 → 192.168.0.106  TCP  54  62150 → 10000 [ACK] Seq=82 Ack=126 Win=254 Len=0
5191  113.489935  192.168.0.106 → 192.168.0.65  TCP  66  10000 → 62150 [PSH, ACK] Seq=126 Ack=82 Win=4096 Len=12
5192  113.537800  192.168.0.65 → 192.168.0.106  TCP  54  62150 → 10000 [ACK] Seq=82 Ack=138 Win=254 Len=0
</pre>
</div>

<p>
<strong>ניתוח התעבורה:</strong> התעבורה מתקיימת בין כתובת IP מקור 192.168.0.65:62150 (הלקוח) לכתובת IP יעד 192.168.0.106:10000 (השרת), וכל החבילות משתמשות באותו חיבור TCP (פורט 62150). כל החבילות עם נתונים משתמשות בדגל <code>PSH, ACK</code>, המציין שהנתונים צריכים להישלח מיידית לשכבת היישום. חבילות האישור (ACK) ללא נתונים הן בגודל 54 בתים (header בלבד), בעוד שחבילות עם נתונים הן בגודל 58-94 בתים (כולל header + נתונים).
</p>

<p>
מספרי הרצף (Seq) גדלים עם כל חבילה שנשלחת, ומספרי האישור (Ack) מתעדכנים עם כל חבילה שמתקבלת. החבילה הראשונה מתחילה ב-Seq=1 (לאחר ה-handshake). גדלי ההודעות משתנים: הודעות קצרות (4, 5, 12, 13 בתים), הודעות בינוניות (19, 26, 37, 40 בתים), וחבילות ACK ללא נתונים (54 בתים - TCP header בלבד). גודל החלון (Window Size) הוא Win=254 עבור הלקוח (חלון קטן) ו-Win=4096 עבור השרת (חלון גדול יותר).
</p>

<p>
<strong>הבדל בין שני הניתוחים:</strong>
</p>

<p>
בתעבורה זו (שיחה במהלך חיבור קיים) אין חבילות SYN כי הלכידה ב-Wireshark החלה <strong>לאחר שהחיבור TCP כבר הוקם</strong>. 
החיבור בין הלקוח (192.168.0.65:62150) לשרת (192.168.0.106:10000) כבר היה פעיל כאשר התחילה הלכידה, 
לכן לא נלכדו שלבי ה-handshake הראשוניים (SYN → SYN-ACK → ACK).
</p>

<p>
בניגוד לתעבורה הקודמת (הקמת החיבור), כאן הלכידה החלה בזמן שהחיבור כבר היה פעיל ומתקיימת בו תקשורת בין הלקוחות. 
לכן כל החבילות שנלכדו הן חבילות PSH+ACK (העברת נתונים) וחבילות ACK (אישור קבלה), ללא שלבי ה-handshake.
</p>

<h4>פלט - ייצוא JSON:</h4>

<p>
ניתן לייצא את הלוגים ל-JSON:
</p>

<pre>
[
  {
    "timestamp": "2026-01-02T12:34:56.123456",
    "client_id": "192.168.0.65:64401",
    "direction": "received",
    "message": "GET /index.html HTTP/1.1"
  },
  {
    "timestamp": "2026-01-02T12:34:56.234567",
    "client_id": "192.168.0.65:64401",
    "direction": "sent",
    "message": "server received GET /INDEX.HTML HTTP/1.1"
  }
]
</pre>

<h3>2.4 ניתוח תעבורה של היישום עד שכבת הרשת (כולל)</h3>

<p>
ניתוח התעבורה של היישום ב-Wireshark מראה את כל שכבות המודל TCP/IP עד שכבת הרשת:
</p>

<h4>שכבת הקו (Link Layer - Ethernet):</h4>

<ul>
    <li><strong>Ethernet II Header:</strong>
        <ul>
            <li>Destination MAC: AA:BB:CC:DD:EE:02 (כתובת יעד)</li>
            <li>Source MAC: AA:BB:CC:DD:EE:01 (כתובת מקור)</li>
            <li>Type: 0x0800 (IPv4)</li>
        </ul>
    </li>
    <li><strong>גודל Frame:</strong> 66-142 בתים (תלוי בגודל הנתונים)</li>
</ul>

<h4>שכבת הרשת (Network Layer - IP):</h4>

<ul>
    <li><strong>IP Header:</strong>
        <ul>
            <li>Version: 4 (IPv4)</li>
            <li>IHL: 5 (20 בתים)</li>
            <li>Total Length: 52-140 בתים</li>
            <li>Identification: מספר ייחודי לחבילה</li>
            <li>Flags: DF (Don't Fragment)</li>
            <li>TTL: 64 (Time To Live)</li>
            <li>Protocol: 6 (TCP)</li>
            <li>Source IP: 192.168.0.65</li>
            <li>Destination IP: 192.168.0.106</li>
        </ul>
    </li>
</ul>

<p>
<strong>ניתוח כתובות IP:</strong>
</p>
<ul>
    <li>כתובת מקור: 192.168.0.65 (המחשב הלקוח)</li>
    <li>כתובת יעד: 192.168.0.106 (השרת)</li>
    <li>שתי הכתובות הן ברשת מקומית (192.168.0.0/24)</li>
    <li>TTL=64 הוא ערך נפוץ למחשבים מקומיים</li>
</ul>

<h4>שכבת התעבורה (Transport Layer - TCP):</h4>

<ul>
    <li><strong>TCP Header:</strong>
        <ul>
            <li>Source Port: 64401-64421 (פורטים דינמיים של הלקוח)</li>
            <li>Destination Port: 10000 (פורט השרת)</li>
            <li>Sequence Number: מספר רצף לכל byte שנשלח</li>
            <li>Acknowledgment Number: מספר הרצף הצפוי הבא</li>
            <li>Header Length: 20 בתים (ברירת מחדל)</li>
            <li>Flags:
                <ul>
                    <li>SYN: פתיחת חיבור</li>
                    <li>ACK: אישור קבלה</li>
                    <li>FIN: סגירת חיבור</li>
                    <li>RST: איפוס חיבור</li>
                    <li>PSH: דחיפת נתונים לשכבת היישום</li>
                </ul>
            </li>
            <li>Window Size: 65535 (בתחילה), 65280 (לאחר handshake)</li>
            <li>Checksum: בדיקת תקינות</li>
        </ul>
    </li>
</ul>

<p>
<strong>ניתוח TCP Handshake:</strong>
</p>
<ol>
    <li>חבילה 2821: SYN מ-64401 ל-10000 (Seq=0)</li>
    <li>חבילה 2835: SYN-ACK מ-10000 ל-64401 (Seq=0, Ack=1)</li>
    <li>חבילה 2837: ACK מ-64401 ל-10000 (Seq=1, Ack=1)</li>
</ol>

<p>
<strong>ניתוח העברת נתונים:</strong>
</p>
<ul>
    <li>הלקוח שולח HTTP request עם PSH+ACK (חבילה 2839)</li>
    <li>השרת משלח ACK (חבילה 2840)</li>
    <li>השרת משלח תגובה HTTP עם PSH+ACK (חבילה 2841, 2844)</li>
    <li>הלקוח משלח ACK (חבילה 2842)</li>
</ol>

<h4>שכבת היישום (Application Layer - HTTP):</h4>

<ul>
    <li><strong>HTTP Requests:</strong>
        <ul>
            <li>GET /index.html HTTP/1.1</li>
            <li>GET /css/styles.css HTTP/1.1</li>
            <li>GET /js/app.js HTTP/1.1</li>
            <li>POST /api/login HTTP/1.1</li>
        </ul>
    </li>
    <li><strong>HTTP Responses:</strong>
        <ul>
            <li>HTTP/1.1 200 OK</li>
            <li>HTTP/1.1 404 Not Found</li>
            <li>HTTP/1.1 201 Created</li>
        </ul>
    </li>
</ul>

<h4>סיכום ניתוח שכבות:</h4>

<table>
    <tr>
        <th>שכבה</th>
        <th>פרוטוקול</th>
        <th>גודל Header (בתים)</th>
        <th>מידע עיקרי</th>
    </tr>
    <tr>
        <td>יישום</td>
        <td>HTTP</td>
        <td>משתנה</td>
        <td>בקשות ותגובות HTTP</td>
    </tr>
    <tr>
        <td>תעבורה</td>
        <td>TCP</td>
        <td>20</td>
        <td>פורטים, מספרי רצף, דגלים</td>
    </tr>
    <tr>
        <td>רשת</td>
        <td>IPv4</td>
        <td>20</td>
        <td>כתובות IP, TTL</td>
    </tr>
    <tr>
        <td>קו</td>
        <td>Ethernet II</td>
        <td>14</td>
        <td>כתובות MAC</td>
    </tr>
</table>

<h4>תובנות מהניתוח:</h4>

<ul>
    <li><strong>Overhead:</strong> כל חבילה מכילה ~54 בתים overhead (Ethernet 14 + IP 20 + TCP 20) לפני הנתונים</li>
    <li><strong>מספר חיבורים:</strong> כל הודעה נשלחת בחיבור נפרד, מה שיוצר overhead של handshake לכל הודעה</li>
    <li><strong>RST packets:</strong> חלק מהחיבורים מסתיימים עם RST, מה שמעיד על סגירה מהירה</li>
    <li><strong>Window Size:</strong> גודל החלון מתחיל ב-65535 ויורד ל-65280 לאחר handshake (עקב scaling)</li>
</ul>

<h3>2.5 ממשקים גרפיים (GUI) - סקירה ויזואלית</h3>

<p>
הפרויקט כולל ממשקים גרפיים מתקדמים לשרת ולקוח, המאפשרים ניהול נוח וניטור בזמן אמת של התקשורת. להלן סקירה ויזואלית של הממשקים הסופיים:
</p>

<h4>ממשק הלקוח (Client GUI):</h4>

<p>
<img src="img/client1.png" alt="ממשק הלקוח - Chat Client">
</p>

<p>
ממשק הלקוח מציג ממשק צ'אט מלא עם תמיכה בצ'אט פרטי וצ'אט קבוצתי. <strong>בחלק העליון</strong> ניתן לראות את הגדרות החיבור: שם המשתמש (ben), כתובת השרת (192.168.0.106), ופורט (10000), יחד עם כפתורי Connect/Disconnect וסטטוס חיבור (Connected). <strong>בחלק השמאלי</strong> מוצגים רשימת המשתמשים המחוברים (dadcha, yaniv) ורשימת הקבוצות (lion_king), עם אפשרות לבחור משתמש או קבוצה ולפתוח צ'אט. <strong>בחלק הימני</strong> מוצג אזור הצ'אט הראשי עם שם המשתמש/קבוצה הנוכחית (yaniv), היסטוריית ההודעות, ושדה קלט לכתיבת הודעות חדשות. הממשק מציג הודעות מערכת כמו "[10:39] System: Connected to yaniv. You can now chat!" ומאפשר תקשורת בזמן אמת.
</p>

<h4>ממשק השרת - תצוגת טבלה (Server GUI - Table View):</h4>

<p>
<img src="img/server.png" alt="ממשק השרת - תצוגת טבלה">
</p>

<p>
ממשק השרת מציג לוח בקרה מקיף לניהול השרת ולקוחותיו. <strong>בחלק העליון</strong> מוצגות הגדרות השרת (Host: 0.0.0.0, Port: 10000) עם כפתורי Start/Stop וסטטוס (Status: Running). <strong>בחלק הסטטיסטיקות</strong> מוצגים נתונים בזמן אמת: 3 לקוחות מחוברים, 56 הודעות בסך הכל (46 התקבלו, 10 נשלחו). <strong>בחלק המרכזי</strong> מוצגת טבלה מפורטת של כל הלקוחות המחוברים, כולל: Client ID (כתובת IP ופורט), שם המשתמש, כתובת, זמן חיבור, מספר הודעות שנשלחו/התקבלו, סטטוס צ'אט (In Chat: Yes/No), והקבוצות שהלקוח חבר בהן. <strong>בחלק התחתון</strong> מוצגים לוגי השרת עם כל הפעילות, כולל הודעות שהתקבלו, צ'אטים שנפתחו, יצירת קבוצות, והזמנות לקבוצות. הממשק כולל גם כפתורים לייצוא לוגים וסטטיסטיקות.
</p>

<h4>ממשק השרת - תצוגת רשת ויזואלית (Server GUI - Visual Network):</h4>

<p>
<img src="img/topology.png" alt="ממשק השרת - תצוגת רשת ויזואלית">
</p>

<p>
ממשק השרת כולל גם תצוגה ויזואלית מתקדמת של טופולוגיית הרשת. <strong>בחלק המרכזי</strong> מוצגת מפה ויזואלית של הרשת עם: <strong>צמתים עגולים</strong> (לקוחות - yaniv, dadcha, ben), <strong>קווים רציפים</strong> (חיבורי צ'אט פעילים בין yaniv ל-dadcha), <strong>תיבות מלבניות</strong> (קבוצות - lion_king), ו-<strong>קווים מקווקווים</strong> (חברות בקבוצות - כל שלושת הלקוחות חברים בקבוצה lion_king). <strong>בחלק הימני</strong> מוצגים פאנלים נוספים: רשימת קבוצות עם מספר החברים, רשימת לקוחות עם סטטוס (In chat / Available) והקבוצות שלהם, ומקרא המסביר את המשמעות של כל סוג קו וצורה במפה. התצוגה הוויזואלית מאפשרת הבנה מיידית של מצב הרשת, הקשרים בין הלקוחות, והפעילות הנוכחית.
</p>

<p>
<strong>יתרונות הממשקים הגרפיים:</strong> הממשקים מספקים חוויית משתמש נוחה, ניטור בזמן אמת, ויזואליזציה של הרשת, וניהול מלא של השרת והלקוחות דרך ממשק ידידותי ומובן.
</p>

<h2>3. תיאור שימוש בבינה מלאכותית (אם היה שימוש ב-AI)</h2>

<h3>3.1 מטרות השימוש</h3>

<p>
בפרויקט זה נעשה שימוש בכלי בינה מלאכותית (AI) במספר שלבים:
</p>

<ul>
    <li><strong>תכנון וארכיטקטורה:</strong> קבלת ייעוץ על מבנה הפרויקט, ארגון קבצים, ותכנון ארכיטקטורה</li>
    <li><strong>פיתוח קוד:</strong> כתיבת פונקציות, מימוש תכונות, ושיפור קוד קיים</li>
    <li><strong>תיקון באגים:</strong> זיהוי ותיקון שגיאות בקוד</li>
    <li><strong>תיעוד:</strong> כתיבת תיעוד, הערות בקוד, ודוחות</li>
    <li><strong>למידה:</strong> הבנת מושגים חדשים, פרוטוקולים, וטכנולוגיות</li>
</ul>

<h3>3.2 דוגמאות פרומפטים</h3>

<p>
להלן דוגמאות לפרומפטים שנעשה בהם שימוש במהלך פיתוח הפרויקט:
</p>

<ol>
    <li><strong>תכנון ארכיטקטורה:</strong>
        <pre>
אני מפתח פרויקט TCP/IP בקורס תקשורת מחשבים. הפרויקט צריך לכלול:
1. שרת ולקוח סינכרוניים (server.py, client.py)
2. שרת ולקוח אסינכרוניים עם asyncio
3. ממשקים גרפיים עם tkinter לשרת ולקוח
4. מערכת לוגים וניהול הגדרות

איך כדאי לארגן את המבנה? אני חושב על:
- prt2/ (תיקייה ראשית)
  - server.py, client.py (גרסאות סינכרוניות)
  - async_impl/ (גרסאות אסינכרוניות)
  - gui/ (ממשקים גרפיים)
  - utils/ (לוגים, הגדרות)

האם המבנה הזה הגיוני? יש המלצות לשיפור?
        </pre>
    </li>
    <li><strong>פיתוח קוד - אריזה (Encapsulation):</strong>
        <pre>
אני צריך לכתוב פונקציה simulate_encapsulation() ב-Jupyter Notebook 
שמבצעת אריזה של הודעת HTTP בשכבות מודל TCP/IP.

הפונקציה צריכה:
- לקבל שורה מ-CSV עם: msg_id, app_protocol, src_app, dst_app, 
  src_port, dst_port, message, timestamp
- ליצור dictionary היררכי עם שכבות:
  * Application: protocol="HTTP", payload=message
  * Transport: protocol="TCP", src_port (אקראי 1024-65535), 
    dst_port=10000, seq_num (אקראי), ack_num (אקראי), flags="PSH, ACK"
  * Network: protocol="IPv4", src_ip="192.168.0.65", 
    dst_ip="192.168.0.106", ttl=64
  * Link: src_mac, dst_mac (פורמט AA:BB:CC:DD:EE:XX), type="Ethernet II"

כתוב את הפונקציה המלאה עם docstring בעברית.
        </pre>
    </li>
    <li><strong>פיתוח קוד - שרת אסינכרוני:</strong>
        <pre>
אני מפתח שרת TCP אסינכרוני ב-Python עם asyncio. 
השרת צריך:
- להאזין על פורט 10000 (מקובץ config.json)
- לקבל חיבורים מרובים בו-זמנית
- לקרוא הודעות HTTP מהלקוח
- לשלוח תגובה: "server received [MESSAGE]"
- לרשום כל הודעה ב-log עם timestamp, client_id, direction
- לטפל בסגירת חיבורים נכון

הקוד הנוכחי שלי ב-server_async.py משתמש ב-asyncio.start_server() 
אבל יש לי בעיה עם טיפול בשגיאות. איך לטפל נכון ב-exceptions 
בחיבורים אסינכרוניים? תן דוגמת קוד מלאה.
        </pre>
    </li>
    <li><strong>תיקון באגים - GUI:</strong>
        <pre>
יש לי בעיה ב-client_gui.py. כשאני לוחץ על "Send Messages" 
הממשק קופא ולא מגיב. הקוד משתמש ב-threading לשליחת ההודעות:

def send_messages_thread(self):
    # קורא CSV ושולח הודעות
    
button = Button(..., command=lambda: threading.Thread(
    target=self.send_messages_thread).start())

מה הבעיה? איך לתקן את זה כך שהממשק יישאר מגיב 
ויציג התקדמות בזמן אמת?
        </pre>
    </li>
    <li><strong>תיעוד - דוח מסכם:</strong>
        <pre>
אני צריך לכתוב דוח מסכם בעברית על הפרויקט. 
הדוח צריך לכלול:
1. הסבר על תהליך האריזה (encapsulation) עם דוגמאות
2. תיאור תהליך הלכידה ב-Wireshark
3. ניתוח תעבורה שנלכדה - TCP handshake, העברת נתונים, סגירת חיבור
4. הסבר על מבנה הקוד והארכיטקטורה
5. הוראות התקנה והרצה

כתוב סעיף מפורט על ניתוח תעבורה TCP/IP ב-Wireshark, 
כולל הסבר על כל שכבה (Ethernet, IP, TCP, HTTP) 
עם דוגמאות מהתעבורה שנלכדה.
        </pre>
    </li>
    <li><strong>למידה - TCP Handshake:</strong>
        <pre>
אני רוצה להבין לעומק את תהליך ה-TCP three-way handshake. 
ב-Wireshark אני רואה:
- חבילה 1699: SYN מ-192.168.0.65:62263 ל-192.168.0.106:10000
- חבילה 1712: SYN-ACK מ-192.168.0.106:10000 ל-192.168.0.65:62263
- חבילה 1713: ACK מ-192.168.0.65:62263 ל-192.168.0.106:10000

תסביר:
1. מה כל דגל אומר (SYN, ACK)?
2. למה ב-SYN ה-Seq=0 אבל ב-ACK ה-Ack=1?
3. מה זה MSS, WS, SACK_PERM שאני רואה ב-headers?
4. מה קורה אם אחד מהשלבים נכשל?

תן הסבר מפורט עם דוגמאות מהחבילות שלי.
        </pre>
    </li>
</ol>

<p>
<strong>הערה חשובה:</strong> השימוש ב-AI היה מלווה בהבנה, למידה, ואימות של כל הקוד וההסברים. 
כל הקוד נבדק, נבדק, והותאם לצרכים הספציפיים של הפרויקט.
</p>

<h2>4. סיכום</h2>

<div class="summary">
<p>
הפרויקט מציג יישום מלא של תקשורת TCP/IP בשני חלקים עיקריים:
</p>

<ul>
    <li><strong>חלק 1:</strong> הדמיית תהליך האריזה של חבילות נתונים בשכבות מודל TCP/IP, 
    יצירת קובץ CSV עם הודעות HTTP, שליחת תעבורה, ולכידת התעבורה ב-Wireshark לניתוח מעמיק</li>
    <li><strong>חלק 2:</strong> פיתוח מעשי של שרת ולקוח TCP/IP עם גרסאות סינכרוניות ואסינכרוניות, 
    ממשקים גרפיים, מערכת לוגים, ניהול הגדרות, וניתוח תעבורה עד שכבת הרשת</li>
</ul>

<p>
הפרויקט מספק הבנה מעמיקה של מודל TCP/IP, תהליך האריזה, תכנות תקשורת, 
וטכנולוגיות מתקדמות כמו תכנות אסינכרוני וממשקים גרפיים. כל הדרישות מולאו בהצלחה, 
והקוד הוא מקצועי, מתועד היטב, ומוכן לשימוש.
</p>
</div>