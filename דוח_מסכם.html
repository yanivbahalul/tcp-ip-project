<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>דוח מסכם - פרויקט TCP/IP</title>
    <style>
        body {
            font-family: 'Arial', 'David', sans-serif;
            font-size: 12pt;
            line-height: 1.8;
            margin: 40px;
            padding: 20px;
            background-color: #ffffff;
            color: #000000;
            text-align: right;
            direction: rtl;
        }
        
        h1 {
            font-size: 28pt;
            font-weight: bold;
            margin-top: 30px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #333;
            text-align: center;
            direction: rtl;
        }
        
        h2 {
            font-size: 22pt;
            font-weight: bold;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-top: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #666;
            color: #1a1a1a;
            text-align: right;
            direction: rtl;
        }
        
        h3 {
            font-size: 18pt;
            font-weight: bold;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-top: 10px;
            color: #2a2a2a;
            text-align: right;
            direction: rtl;
        }
        
        h4 {
            font-size: 15pt;
            font-weight: bold;
            margin-top: 25px;
            margin-bottom: 12px;
            padding-top: 8px;
            color: #3a3a3a;
            text-align: right;
            direction: rtl;
        }
        
        h5 {
            font-size: 13pt;
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #4a4a4a;
            text-align: right;
            direction: rtl;
        }
        
        p {
            margin-top: 10px;
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        
        img {
            width: 900px;
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: right;
        }
        
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        pre {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 11pt;
            text-align: right;
            direction: rtl;
        }
        
        code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11pt;
            text-align: right;
            direction: rtl;
        }
        
        .abstract {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 20px;
            margin: 20px 0;
        }
        
        .summary {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 20px;
            margin: 20px 0;
        }
        
        ul, ol {
            margin: 10px 0;
            padding-right: 30px;
            text-align: right;
            direction: rtl;
        }
        
        li {
            margin: 8px 0;
            text-align: right;
            direction: rtl;
        }
    </style>
</head>
<body>

<h1>דוח מסכם</h1>
<p style="text-align: center; font-size: 13pt; margin: 0 0 12px 0; padding: 0; font-weight: normal;">פרויקט גמר</p>
<p style="text-align: center; font-size: 12pt; margin: 0 0 30px 0; padding: 0; font-weight: normal;"><strong>קורס:</strong> תקשורת מחשבים ורשתות</p>

<h2>חלק 1 – אריזת נתונים ולכידת מנות בעזרת Wireshark</h2>

<h3>1. יצירת קובץ CSV – שכבת היישום:</h3>

<p>
בשלב הראשון נבחר פרוטוקול היישום DHCP לצורך הפרויקט.
לצורך כך נוצר קובץ CSV המכיל רצף של הודעות ברמת היישום,
כאשר כל שורה מייצגת הודעה אחת בתהליך התקשורת בין הלקוח לשרת.
</p>

<p>
קובץ ה־CSV כולל את השדות הבאים:
</p>

<ul>
    <li><strong>msg_id</strong> – מזהה הודעה</li>
    <li><strong>app_protocol</strong> – פרוטוקול היישום (DHCP)</li>
    <li><strong>src_port</strong> – מקור פורט (68 עבור לקוח DHCP)</li>
    <li><strong>dst_port</strong> – יעד פורט (67 עבור שרת DHCP)</li>
    <li><strong>message</strong> – תוכן ההודעה (Discover/Offer/Request/ACK/Release/NAK)</li>
    <li><strong>timestamp</strong> – זמן יחסי לשליחת ההודעה</li>
</ul>

<p>
הקובץ מכיל 41 הודעות DHCP המדמות 10 תרחישי הקצאת כתובות IP:
</p>

<ul>
    <li><strong>הודעות Discover</strong> – הלקוח מחפש שרת DHCP (מפורט 68 לפורט 67)</li>
    <li><strong>הודעות Offer</strong> – השרת מציע כתובת IP (מפורט 67 לפורט 68, כתובות 192.168.1.100-109)</li>
    <li><strong>הודעות Request</strong> – הלקוח מבקש את הכתובת שהוצעה (מפורט 68 לפורט 67)</li>
    <li><strong>הודעות ACK</strong> – השרת מאשר את הקצאת הכתובת (מפורט 67 לפורט 68)</li>
    <li><strong>הודעת Release</strong> – הלקוח משחרר כתובת IP (בהודעה מס' 22, transaction 5)</li>
    <li><strong>הודעת NAK</strong> – השרת דוחה בקשת כתובת (בהודעה מס' 33, transaction 8)</li>
</ul>

<p>
<strong>הערה:</strong> השדות src_port ו־dst_port נכללו בקובץ ה־CSV לצורך התאמה לשימוש במחברת Jupyter, אשר עושה שימוש בפורטים כחלק מתהליך יצירת חבילות התעבורה. פורט 67 מייצג את שרת ה־DHCP, ואילו פורט 68 מייצג את יישומי הלקוח (DHCP Client).
</p>

<p>
<strong>* קובץ ה־CSV נוצר בעזרת כלי בינה מלאכותית, לצורך יצירת נתוני דוגמה המדמים תעבורת DHCP. הנתונים שימשו כקלט לניתוח ואינם מייצגים תעבורה אמיתית.</strong>
</p>

<h3>2. עבודה במחברת Jupyter:</h3>

<p>
קובץ ה-CSV נטען למחברת Jupyter שסופקה במסגרת הפרויקט.
המחברת מבצעת עיבוד של כל שורה בקובץ כיחידת הודעה עצמאית ומדגימה את תהליך האריזה (Encapsulation) של המידע בין שכבות הרשת.
</p>

<p>
תהליך האריזה מתבצע לפי המודל הבא:
</p>

<ul>
    <li><strong>שכבת היישום (Application)</strong> – הודעת DHCP מתוך ה-CSV</li>
    <li><strong>שכבת התעבורה (Transport)</strong> – עטיפה בפרוטוקול TCP עם פורטים 68 (מקור) ו-67 (יעד)</li>
    <li><strong>שכבת הרשת (Network)</strong> – עטיפה בפרוטוקול IP</li>
    <li><strong>שכבת הקישור (Data Link)</strong> – שליחה דרך ממשק Loopback</li>
</ul>

<h3>3. יצירת תעבורת רשת אמיתית:</h3>

<p>
באמצעות Python וספריית Scapy נוצרו חבילות TCP אמיתיות, כאשר תוכן ההודעות מתוך קובץ ה-CSV משמש כ-payload של החבילות.
</p>

<p>
החבילות נשלחו דרך ממשק ה-Loopback (127.0.0.1) אל פורט יעד 12345, כפי שנקבע במחברת Jupyter.
שליחה זו מתבצעת דרך מחסנית הרשת של מערכת ההפעלה באמצעות ספריית Scapy (או raw sockets) ואינה סימולציה תיאורטית.
תוכן הודעות ה-DHCP מקובץ ה-CSV משמש כ-payload של החבילות, אך הפורט היעד הוא 12345 כפי שהוגדר במחברת, ולא פורטי ה-DHCP המקוריים (67/68).
</p>

<h3>4. לכידת התעבורה באמצעות Wireshark:</h3>

<p>
לכידת התעבורה בוצעה באמצעות תוכנת Wireshark על ממשק Npcap Loopback Adapter.
הוגדר פילטר תצוגה:
</p>

<pre>tcp.port == 12345 && ip.addr == 127.0.0.1</pre>

<p>
<strong>הסבר על בחירת הפורט 12345:</strong>
פורט 12345 נקבע כפורט יעד במחברת Jupyter לצורך יצירת החבילות TCP/IP. 
פורט זה נבחר לצורך ההדגמה וההרצה של הפרויקט, והוא אינו קשור לפורטים ה-DHCP הסטנדרטיים (67 ו-68) המצויים בקובץ ה-CSV. 
בעוד שקובץ ה-CSV מכיל את פורטי ה-DHCP המקוריים (67 לשרת ו-68 ללקוח), המחברת Jupyter משתמשת בפורט 12345 כפורט יעד אחיד ליצירת כל החבילות TCP/IP, ללא קשר לתוכן הודעות ה-DHCP שבהן.
זה מאפשר לסנן ולנתח את כל התעבורה שנוצרה על ידי המחברת בפילטר אחד ברור.
</p>

<p>
<strong>הערה חשובה:</strong> חשוב לציין שזה ידוע שפורטי ה-DHCP הסטנדרטיים הם 67 (שרת DHCP) ו-68 (לקוח DHCP), והם משקפים את הפרוטוקול המקורי. במהלך הפרויקט פעלנו בהתאם להנחיות המחברת Jupyter, שהגדירה את פורט 12345 כפורט יעד, ולכן הצילומי מסך ב-Wireshark בוצעו בהתאם למחברת ומוצגים עם הפורט 12345.
</p>

<p>
כמו כן, בוצעה בדיקה נוספת על הפורטים המקוריים (67 ו-68) בחיפוש ב-loopback באמצעות פילטרים מתאימים, והגענו לאותם ממצאים מבחינת מבנה החבילות, שכבות הפרוטוקול, דגלי TCP, ותוכן ה-payload. 
זה מוכיח שהאריזה והניתוח הם נכונים ועקביים, ללא תלות בבחירת הפורט הספציפי, שכן הפורט משמש רק לצורך זיהוי החבילות ולא משפיע על מבנה השכבות והתוכן של הודעות ה-DHCP.
</p>

<p>
במהלך הרצת המחברת נלכדו חבילות TCP שנשלחו על ידי הקוד. הלכידה נשמרה לקובץ בפורמט pcapng לצורך ניתוח והגשה.
</p>

<h3>5. ניתוח התעבורה שנלכדה:</h3>

<p>
בלכידה ניתן לראות:
</p>

<ul>
    <li>חבילות בפרוטוקול TCP</li>
    <li>כתובת מקור ויעד: 127.0.0.1</li>
    <li>פורט מקור אקראי (בין 1024-65535, כפי שנקבע במחברת) ופורט יעד 12345</li>
    <li>דגלי TCP כגון PSH ו-ACK (flags=0x18)</li>
    <li>נתוני payload המייצגים הודעות DHCP (Discover / Offer / Request / ACK) מתוך קובץ ה-CSV</li>
</ul>

<p>
בנוסף, נצפו חבילות עם דגל RST.
חבילות אלו נוצרות כתוצאה מכך שאין שרת DHCP פעיל המאזין על פורט 12345 באמצעות ה-Loopback בממשק TCP.
זוהי התנהגות תקינה של פרוטוקול TCP ואינה מעידה על שגיאה במימוש.
</p>

<h4>ניתוח התעבורה המלאה שנלכדה:</h4>

<p>
בצילום המסך המוצג ניתן לראות את כל התעבורה שנלכדה באמצעות Wireshark עם הפילטר: <code>tcp.port == 12345 && ip.addr == 127.0.0.1</code>.
התעבורה מציגה דפוס ברור וחוזר של חבילות TCP.
</p>

<p>
<img src="img/csvresult.png" alt="ניתוח התעבורה המלאה - רשימת חבילות TCP שנלכדו ב-Wireshark">
</p>

<p>
<strong>דפוס התעבורה הנצפה:</strong>
</p>

<p>
ניתן להבחין בדפוס שחוזר על עצמו בכל התעבורה:
</p>

<ol>
    <li><strong>חבילות [PSH, ACK] מהלקוח:</strong> חבילות עם נתונים (48-49 בתים) מהפורט 62895 לפורט 12345, כוללות את ה-payload של הודעות ה-DHCP.</li>
    <li><strong>חבילות [TCP Retransmission]:</strong> חבילות שנשלחות מחדש כאשר החבילה המקורית לא מקבלת אישור מהשרת.</li>
    <li><strong>חבילות [RST] מהשרת:</strong> חבילות Reset (0 בתים) הנשלחות מהשרת ללקוח, מציינות שאין שרת פעיל המאזין על הפורט.</li>
</ol>

<p>
<strong>הסבר על הדפוס והסיבה להופעת RST ב-Localhost:</strong>
</p>

<p>
הדפוס הנצפה מראה תהליך ברור: הלקוח (62895) שולח חבילות עם נתונים (PSH, ACK) לשרת (12345), אך השרת משיב עם חבילות RST (Reset) במקום ACK תקין.
</p>

<p>
<strong>מדוע זה קורה ב-Localhost?</strong>
</p>

<ul>
    <li><strong>אין שרת DHCP אמיתי מאזין:</strong> הקוד שלנו יוצר חבילות TCP/IP ומושלח אותן דרך ממשק ה-Loopback (127.0.0.1) לפורט 12345, אך בפועל אין שרת DHCP אמיתי המאזין על פורט זה במחשב המקומי.</li>
    <li><strong>תגובת מערכת ההפעלה:</strong> כאשר מערכת ההפעלה (Kernel) מקבלת חבילת TCP לפורט שלא מנוהל על ידי יישום פעיל, היא שולחת חבילת RST כדי להודיע לשולח שיש לסגור את החיבור.</li>
    <li><strong>ללא Handshake אמיתי:</strong> הקוד שלנו שולח חבילות עם דגלי PSH+ACK כאילו החיבור כבר קיים, אך למעשה לא בוצע תהליך Three-Way Handshake (SYN → SYN-ACK → ACK) אמיתי עם שרת פעיל. מערכת ההפעלה מזהה את החבילות הללו כ"פולשות" או לא שייכות לחיבור קיים, ולכן שולחת RST.</li>
    <li><strong>Retransmissions:</strong> כאשר הלקוח לא מקבל ACK על החבילות ששלח (במקום זה הוא מקבל RST), הוא מנסה לשלוח את החבילות שוב - מה שמביא להופעת חבילות [TCP Retransmission].</li>
</ul>

<p>
<strong>זהו התנהגות תקינה:</strong>
התנהגות זו היא תקינה לחלוטין ומצביעה על כך שהחבילות אכן נוצרות ונשלחות דרך מחסנית הרשת של מערכת ההפעלה. 
מטרת הפרויקט היא להדגים את תהליך האריזה (Encapsulation) והשידור של חבילות TCP/IP, ולא לנהל שיחה אמיתית עם שרת פעיל. 
לכן, הופעת ה-RST היא הוכחה לכך שהחבילות אכן נשלחו ונקלטו על ידי מערכת ההפעלה, והתגובה של RST היא התגובה התקנית של מערכת ההפעלה לחבילות שלא שייכות לחיבור קיים.
</p>

<p>
<strong>פרטים טכניים:</strong> כל החבילות עוברות דרך Loopback (127.0.0.1), גדלי החבילות משתנים (44-93 בתים), ומספר החבילות שנלכדו מתאים למספר ההודעות בקובץ ה-CSV (41 הודעות).
</p>

<h4>ניתוח Frame ומעטפת הלכידה:</h4>

<p>
<img src="img/frame.png" alt="ניתוח Frame - פירוט חבילת רשת ב-Wireshark">
</p>

<p>
בצילום המסך מוצגת חבילת רשת (Frame 228, 93 בתים) שנלכדה על ממשק Loopback (lo0). 
החבילה מדגימה את תהליך האריזה: Null/Loopback → IP → TCP, המעבר משכבת הקישור ועד שכבת התעבורה.
הסימון "Bad TCP" מציין ש-Wireshark זיהה תכונות חריגות (כגון retransmission) כתוצאה מכך שאין שרת פעיל המאזין על הפורט.
</p>

<h4>ניתוח שכבת הרשת (IP):</h4>

<p>
בצילום המסך מוצגת שכבת הרשת (IPv4) של החבילה. כתובות המקור והיעד הן 127.0.0.1 (Loopback), מה שמעיד על תעבורה פנימית. 
כותרת ה-IP כוללת: Version 4, Header Length 20 בתים, Protocol TCP (6). כותרת ה-IP עוטפת את כותרת ה-TCP ואת הנתונים ומעבירה אותם דרך ממשק ה-Loopback.
</p>

<h4>ניתוח שכבת התעבורה (TCP):</h4>

<p>
<img src="img/trasport.png" alt="ניתוח שכבת התעבורה TCP - פירוט חבילת TCP ב-Wireshark">
</p>

<p>
בצילום המסך מוצגת שכבת התעבורה (TCP) של חבילה 228. החבילה נשלחת מפורט 62895 לפורט 12345, וכוללת 49 בתים של payload (הודעת DHCP מקובץ ה-CSV).
פרטים עיקריים: Sequence Number 1, Acknowledgment Number 1, Flags PSH+ACK, Window Size 8192, Header Length 20 בתים.
החבילה היא חלק מזרם TCP (Stream 33) ולא הושלמה במלואה (Conversation Incomplete) כתוצאה מאי-קיום שרת פעיל.
הסימון "Retransmitted TCP segment" מציין שהחבילה נשלחה מחדש עקב חוסר אישור מהשרת.
</p>

<h3>6. קישור בין CSV ללכידת Wireshark:</h3>

<p>
כל חבילת TCP שנלכדה מייצגת הודעת DHCP אחת מתוך קובץ ה־CSV.
ניתן לקשר בין שורות כגון msg_id, תוכן ההודעה (message) והזמן היחסי (timestamp) לבין החבילות שנצפו ב־Wireshark, ובכך לעקוב אחר תהליך העברת המידע משכבת היישום ועד לרשת.
</p>

<h2>חלק 2 – כתיבת יישום רשת וניתוח תעבורה של אותו יישום</h2>

<h3>1. מבוא – תיאור כללי של המערכת</h3>

<p>
בחלק זה מימשנו מערכת צ'אט מבוססת תקשורת TCP במודל Client–Server.
המערכת מאפשרת למספר לקוחות להתחבר לשרת בו־זמנית, להזדהות באמצעות שם משתמש ייחודי, ולשלוח הודעות טקסט ללקוחות אחרים בזמן אמת.
התקשורת בין הלקוחות לשרת מתבצעת באמצעות sockets רגילים בלבד, ללא שימוש ב-frameworks או ספריות חיצוניות.
השרת אחראי לניהול החיבורים, לניתוב ההודעות בין הלקוחות ולטיפול בניתוקים.
</p>

<h3>2. מבנה המערכת וארכיטקטורה</h3>

<h4>2.1 מבנה כללי</h4>

<p>
המערכת בנויה משני רכיבים עיקריים:
</p>

<ul>
    <li><strong>Server</strong> – מאזין לחיבורים נכנסים, מנהל לקוחות ומעביר הודעות.</li>
    <li><strong>Client</strong> – מתחבר לשרת, שולח הודעות ומקבל הודעות מלקוחות אחרים.</li>
</ul>

<p>
התקשורת מתבצעת בפרוטוקול TCP, המבטיח אמינות, סדר והגעה מלאה של ההודעות.
</p>

<h4>2.2 הסבר על קובץ השרת (Server)</h4>

<p>
השרת נפתח עם socket אחד המוגדר להאזנה (listen).
כל חיבור חדש מתקבל באמצעות accept, אשר יוצר socket ייעודי ללקוח המחובר. לכל לקוח נוצר thread נפרד, כך שהשרת יכול לטפל במספר לקוחות במקביל.
</p>

<p>
השרת שומר:
</p>

<ul>
    <li>רשימת לקוחות מחוברים (מיפוי בין שם משתמש ל-socket)</li>
    <li>מידע על השולח האחרון, כדי לאפשר תגובה אוטומטית</li>
</ul>

<p>
השרת תומך ב:
</p>

<ul>
    <li>שליחת הודעה ללקוח ספציפי באמצעות סימון @username</li>
    <li>תגובה אוטומטית לשולח האחרון</li>
    <li>טיפול בניתוק יזום או לא צפוי של לקוחות</li>
</ul>

<h4>2.2.1 ממשק גרפי (GUI) לשרת - מערכת צ'אט מתקדמת</h4>

<p>
<img src="img/server1.png" alt="ממשק השרת - מערכת צ'אט מתקדמת">
</p>

<p>
<img src="img/server.png" alt="ממשק השרת - תצוגת טבלה וסטטוס">
</p>

<p>
המערכת כוללת ממשק גרפי מתקדם (tkinter) לניהול השרת עם ניטור בזמן אמת. הממשק כולל: הגדרות שרת (Host, Port, כפתורי Start/Stop), פאנל סטטיסטיקות (מספר לקוחות, הודעות), טבלת לקוחות מחוברים (פרטי חיבור, סטטיסטיקות, סטטוס צ'אט, קבוצות), ואזור לוגים עם אפשרויות ייצוא.
</p>

<p>
<strong>תצוגת רשת ויזואלית (Visual Network):</strong>
</p>

<p>
<img src="img/topology.png" alt="ממשק השרת - תצוגת רשת ויזואלית">
</p>

<p>
<img src="img/network1.png" alt="תצוגת רשת ויזואלית - Network Visualization">
</p>

<p>
הממשק כולל תצוגה ויזואלית מתקדמת של טופולוגיית הרשת: צמתים עגולים ללקוחות (ירוק = בצ'אט פעיל, כחול = זמין), תיבות מלבניות סגולות לקבוצות, קווים כתומים לחיבורי צ'אט, וקווים מקווקווים סגולים לחברות בקבוצות. 
נוסף על כך יש פאנלי מידע: רשימת קבוצות עם חברים, רשימת לקוחות עם סטטוס, ומקרא. התצוגה מתעדכנת בזמן אמת ומאפשרת ניהול נוח של כל הפעילות במערכת.
</p>

<h4>2.3 הסבר על קובץ הלקוח (Client)</h4>

<p>
הלקוח מתחבר לשרת באמצעות TCP socket ומזדהה בשם משתמש.
בקובץ הלקוח קיימים שני threads:
</p>

<ol>
    <li><strong>Thread קבלה</strong> – מאזין כל הזמן להודעות מהשרת (recv) ומדפיס אותן למסך.</li>
    <li><strong>Thread שליחה</strong> – מקבל קלט מהמשתמש (input) ושולח הודעות לשרת (send).</li>
</ol>

<p>
מבנה זה מאפשר קבלת הודעות בזמן אמת, גם בזמן שהמשתמש מקליד.
</p>

<h4>2.3.1 ממשק גרפי (GUI) ללקוח - מערכת צ'אט</h4>

<p>
<img src="img/client1.png" alt="ממשק הלקוח - Chat Client GUI">
</p>

<p>
<img src="img/client.png" alt="ממשק הלקוח - Chat Client GUI עם קבוצה מאובטחת">
</p>

<p>
המערכת כוללת ממשק גרפי מתקדם (tkinter) ללקוח, המאפשר חיבור לשרת וניהול צ'אטים פרטיים וקבוצתיים. הממשק מחולק לשלושה חלקים: פאנל עליון להגדרות חיבור (שם, כתובת, פורט, כפתורי Connect/Disconnect, סטטוס חיבור), פאנל שמאלי עם רשימת משתמשים (כפתור Chat לפתיחת צ'אט פרטי) ורשימת קבוצות (יצירה והצטרפות), ופאנל ימני עם אזור הצ'אט (היסטוריית הודעות עם זמן ושולח, ושדה קלט להקלדת הודעות). הממשק מתעדכן בזמן אמת ומאפשר חוויית שימוש נוחה.
</p>

<h3>3. הוראות התקנה והרצה</h3>

<h4>3.1 דרישות מוקדמות</h4>

<ul>
    <li>Python 3.x</li>
    <li>מערכת הפעלה Windows / Linux / macOS</li>
    <li>אין צורך בהתקנת ספריות נוספות</li>
    <li><strong>הערה למשתמשי macOS:</strong> במערכת macOS, יש להשתמש ב-<code>python3</code> במקום <code>python</code></li>
</ul>

<h4>3.2 הרצת השרת עם ממשק גרפי (GUI)</h4>

<ol>
    <li>לפתוח חלון Terminal / CMD / PowerShell</li>
    <li>לנווט לתיקיית הפרויקט הראשית</li>
    <li>להריץ את הפקודה הבאה:
        <ul>
            <li><strong>Windows/Linux:</strong> <code>python prt2/gui/server_gui.py</code></li>
            <li><strong>macOS:</strong> <code>python3 prt2/gui/server_gui.py</code></li>
        </ul>
    </li>
</ol>

<p>
לאחר ההרצה, יפתח חלון GUI של השרת. 
לחיצה על כפתור "Start Server" תפעיל את השרת, והוא יתחיל להאזין לחיבורים נכנסים על הפורט המוגדר (ברירת מחדל: 10000).
</p>

<h4>3.3 הרצת לקוחות עם ממשק גרפי (GUI)</h4>

<ol>
    <li>לפתוח חלון Terminal נוסף (לכל לקוח)</li>
    <li>לנווט לתיקיית הפרויקט הראשית</li>
    <li>להריץ את הפקודה הבאה:
        <ul>
            <li><strong>Windows/Linux:</strong> <code>python prt2/gui/client_gui.py</code></li>
            <li><strong>macOS:</strong> <code>python3 prt2/gui/client_gui.py</code></li>
        </ul>
    </li>
    <li>בחלון GUI שייפתח, להזין:
        <ul>
            <li>שם משתמש ייחודי בשדה "Name"</li>
            <li>כתובת השרת בשדה "Host" (localhost או כתובת IP של השרת)</li>
            <li>פורט השרת בשדה "Port" (ברירת מחדל: 10000)</li>
        </ul>
    </li>
    <li>לחיצה על כפתור "Connect" לחיבור לשרת</li>
    <li>להתחיל התכתבות באמצעות ממשק הגרפי</li>
</ol>

<p>
<strong>הערות נוספות:</strong>
</p>

<ul>
    <li>ניתן להריץ מספר לקוחות במקביל על ידי פתיחת חלונות Terminal נפרדים</li>
    <li>הממשק הגרפי מספק חוויית שימוש נוחה עם רשימת משתמשים, קבוצות, ואזור צ'אט</li>
    <li>לשימוש בממשק שורת פקודה (CLI) במקום GUI, ניתן להשתמש בקבצים <code>server.py</code> ו-<code>client.py</code> בתיקיית prt2</li>
</ul>

<h3>4. ניתוח תעבורת רשת (Wireshark):</h3>

<h4>4.1 התחלת הקשר בין השרת ללקוח - Three-Way Handshake</h4>

<p>
<img src="img/serverstart.png" alt="התחלת השרת - חיבור לקוח">
</p>

<p>
בצילום המסך מוצגת התחלת השרת והחיבור הראשון של לקוח. השרת מאזין על כתובת 0.0.0.0 (כל הממשקים) ופורט 10000, כפי שניתן לראות בהודעת ההתחלה: "Server listen in: 0.0.0.0:10000".
</p>

<p>
כאשר לקוח מתחבר, השרת מקבל את החיבור ומציג:
</p>

<ul>
    <li><strong>client connected in:</strong> כתובת ה-IP ופורט המקור של הלקוח (למשל: ('192.168.0.65', 62430))</li>
    <li><strong>client online:</strong> מספר הלקוחות המחוברים בזמן אמת</li>
</ul>

<p>
השרת שולח הודעת "welcome" ללקוח המחובר, ומתחיל thread נפרד לטיפול בכל לקוח, מה שמאפשר טיפול במספר לקוחות במקביל.
</p>

<p>
<img src="img/clientstart.png" alt="התחלת הלקוח - חיבור לשרת">
</p>

<p>
בצילום המסך מוצגת התחלת הלקוח והחיבור לשרת. הלקוח מתחבר לכתובת השרת (192.168.0.106) ופורט 10000, כפי שניתן לראות בממשק הגרפי:
</p>

<ul>
    <li><strong>Name:</strong> שם המשתמש (בדוגמה: "ben")</li>
    <li><strong>Host:</strong> כתובת השרת (192.168.0.106)</li>
    <li><strong>Port:</strong> פורט השרת (10000)</li>
    <li><strong>Connection Status:</strong> נקודה ירוקה והטקסט "Connected" - מציין שהחיבור הצליח</li>
</ul>

<p>
לאחר החיבור, הלקוח מקבל הודעת welcome מהשרת, והממשק מציג את רשימת המשתמשים המחוברים ואת הקבוצות הזמינות.
</p>

<h4>4.2 ניתוח תעבורת TCP - Three-Way Handshake ב-Wireshark</h4>

<p>
בצילום המסך מ-Wireshark ניתן לראות את תהליך הקמת החיבור TCP (Three-Way Handshake) בין הלקוח לשרת:
</p>

<ol>
    <li><strong>Packet 9462 - SYN:</strong> הלקוח (192.168.0.65:62430) שולח SYN לשרת (192.168.0.137:10000) עם TCP Options (MSS=1460, WS=256, SACK_PERM).</li>
    <li><strong>Packet 9463 - SYN-ACK:</strong> השרת משיב עם SYN-ACK, מאשר את בקשת ה-SYN ושולח SYN משלו עם TCP Options (MSS=1460, WS=64, SACK_PERM).</li>
    <li><strong>Packet 9464 - ACK:</strong> הלקוח מאשר את ה-SYN של השרת - החיבור הוקם בהצלחה.</li>
</ol>

<p>
<strong>ממצאים:</strong> תהליך ה-Three-Way Handshake הושלם בהצלחה. שני הצדדים משתמשים ב-TCP Options (MSS, Window Scale, SACK). החלון ההתחלתי הוא 65535, ולאחר ה-Handshake השרת שולח Window Update ומגדיל את החלון ל-262144. לאחר הקמת החיבור מתחילה העברת נתונים (השרת שולח welcome, הלקוח שולח את שם המשתמש).
</p>

<p>
לצורך ניתוח תעבורת הרשת של מערכת הצ'אט, בוצעה לכידת תעבורה באמצעות תוכנת Wireshark במהלך הרצת השרת והקליינטים.
הלכידה בוצעה על ממשק הרשת המקומי, מאחר והשרת והלקוחות פועלים ברשת מקומית.
לאחר סיום הלכידה בוצע סינון לפי הפורט של השרת (tcp.port == 10000) על מנת להתמקד אך ורק בתעבורת היישום.
</p>

<h4>4.2.2 ניתוח מפורט של סיום התקשרות - מבט מהצד של השרת</h4>

<p>
<img src="img/finserver.png" alt="ניתוח מפורט של סיום התקשרות - מבט מהצד של השרת">
</p>

<p>
בצילום המסך מוצג ניתוח מפורט של חבילת FIN שנשלחה מהלקוח לשרת (Packet 58715). החבילה מדגימה את כל שכבות מודל TCP/IP - Ethernet עם כתובות MAC, IPv4, ו-TCP עם דגלי FIN+ACK. רצף החבילות מציג את תהליך ה-Four-Way Handshake: FIN מהלקוח → ACK מהשרת → FIN מהשרת → ACK מהלקוח. בהשוואה לתמונה הקודמת, כאן הלקוח יוזם את הניתוק במקום השרת, אך התהליך זהה - סיום חיבור נקי ומסודר המבטיח שכל הצדדים מודעים לסגירת החיבור.
</p>

<h4>4.3 תעבורת השרת בפועל - מאחורי הקלעים של ממשק ה-GUI</h4>

<p>
<img src="img/backend.png" alt="תעבורת השרת בפועל - Follow TCP Stream ב-Wireshark">
</p>

<p>
בצילום המסך מוצגת תעבורת השרת בפועל כפי שנלכדה ב-Wireshark באמצעות תכונת "Follow TCP Stream" (Stream 15). 
התמונה חושפת את כל התקשורת המתרחשת מאחורי הקלעים של ממשק ה-GUI, ומדגימה איך כל פעולה גרפית מתורגמת לפקודות טקסטואליות הנשלחות לשרת.
</p>

<p>
<strong>תהליך החיבור והרשמה:</strong>
</p>

<ol>
    <li><strong>הודעת welcome:</strong> השרת שולח הודעת ברכה ללקוח המחובר: "welcome"</li>
    <li><strong>בקשת שם משתמש:</strong> השרת מבקש מהלקוח לשלוח את שמו: "Please send your name:"</li>
    <li><strong>שליחת שם:</strong> הלקוח שולח את שם המשתמש: "ben"</li>
    <li><strong>אישור הרשמה:</strong> השרת מאשר את הרישום: "Name registered: ben"</li>
    <li><strong>הצגת פקודות זמינות:</strong> השרת מציג ללקוח את רשימת הפקודות הזמינות:
        <ul>
            <li>CONNECT:name - התחברות לצ'אט עם משתמש אחר</li>
            <li>DISCONNECT_CHAT - ניתוק מצ'אט פעיל</li>
            <li>CREATE_GROUP:name - יצירת קבוצה חדשה</li>
            <li>JOIN_GROUP:name - הצטרפות לקבוצה</li>
            <li>LEAVE_GROUP:name - יציאה מקבוצה</li>
            <li>LIST_GROUPS - הצגת רשימת קבוצות</li>
            <li>LIST_USERS - הצגת רשימת משתמשים מחוברים</li>
            <li>GROUP:group_name:message - שליחת הודעה לקבוצה</li>
        </ul>
    </li>
</ol>

<p>
<strong>איך ממשק ה-GUI עובד מאחורי הקלעים:</strong>
</p>

<p>
כל פעולה בממשק הגרפי מתורגמת אוטומטית לפקודת טקסט הנשלחת לשרת דרך החיבור TCP. 
כאשר המשתמש לוחץ על כפתור או מבצע פעולה בממשק, הקוד של הלקוח:
</p>

<ul>
    <li><strong>מתרגם את הפעולה לפקודה:</strong> למשל, לחיצה על כפתור "Chat" עם משתמש אחר מתורגמת לפקודה "CONNECT:yaniv"</li>
    <li><strong>שולח את הפקודה לשרת:</strong> הפקודה נשלחת דרך ה-TCP socket כטקסט פשוט</li>
    <li><strong>ממתין לתגובה:</strong> הלקוח מקבל תגובה מהשרת (כגון "Connected users (2): yaniv, ben")</li>
    <li><strong>מעדכן את הממשק:</strong> התגובה מפורשת והממשק הגרפי מתעדכן בהתאם</li>
</ul>

<p>
<strong>עדכונים אוטומטיים ברקע - בדיקות תקופתיות:</strong>
</p>

<p>
כפי שניתן לראות בתעבורה, המערכת מריצה ברקע בדיקות תקופתיות אוטומטיות על מנת להבטיח שהמידע בממשק הגרפי תמיד מעודכן ונכון:
</p>

<ul>
    <li><strong>LIST_USERS - בדיקת משתמשים מחוברים:</strong>
        <ul>
            <li>המערכת שולחת פקודה "LIST_USERS" לשרת באופן אוטומטי ומתמשך</li>
            <li>השרת משיב עם רשימת המשתמשים המחוברים: "Connected users (2): yaniv, ben"</li>
            <li>התגובה מפורשת והממשק הגרפי מעדכן את רשימת המשתמשים בזמן אמת</li>
            <li>זה מבטיח שאם משתמש מתנתק או מתחבר, כל הלקוחות רואים את השינוי מיידית</li>
        </ul>
    </li>
    <li><strong>LIST_GROUPS - בדיקת קבוצות זמינות:</strong>
        <ul>
            <li>המערכת שולחת פקודה "LIST_GROUPS" לשרת באופן אוטומטי</li>
            <li>השרת משיב עם רשימת הקבוצות: "No groups available" (כשאין קבוצות) או רשימת קבוצות</li>
            <li>הממשק הגרפי מעדכן את רשימת הקבוצות בהתאם</li>
            <li>זה מבטיח שכל הלקוחות רואים את הקבוצות החדשות שנוצרות ואת השינויים בקבוצות הקיימות</li>
        </ul>
    </li>
</ul>

<p>
<strong>סטטיסטיקות התעבורה:</strong>
</p>

<p>
בתחתית צילום המסך ניתן לראות את סטטיסטיקות הזרם:
</p>

<ul>
    <li><strong>Packet 7229:</strong> החבילה הנוכחית שנצפית</li>
    <li><strong>55 client pkt(s):</strong> 55 חבילות נשלחו מהלקוח לשרת</li>
    <li><strong>56 server pkt(s):</strong> 56 חבילות נשלחו מהשרת ללקוח</li>
    <li><strong>106 turn(s):</strong> 106 "סיבובים" של תקשורת (פקודה + תגובה)</li>
    <li><strong>Entire conversation (2226 bytes):</strong> סה"כ 2226 בתים נשלחו בכל הזרם</li>
</ul>

<p>
<strong>תובנות חשובות:</strong>
</p>

<ul>
    <li><strong>ממשק גרפי מול תקשורת טקסטואלית:</strong> הממשק הגרפי מספק חוויית משתמש נוחה, אך מאחורי הקלעים התקשורת היא טקסטואלית פשוטה ופרוטוקול תקשורת ברור ומוגדר</li>
    <li><strong>עדכונים בזמן אמת:</strong> הבדיקות האוטומטיות ברקע מבטיחות שהמידע בממשק תמיד מעודכן, ללא צורך ב-"רענון ידני"</li>
    <li><strong>פרוטוקול תקשורת מובנה:</strong> כל פעולה במערכת מתורגמת לפקודה ספציפית עם פורמט מוגדר, מה שמאפשר תקשורת ברורה ואמינה בין הלקוח לשרת</li>
    <li><strong>ניהול מצב בשרת:</strong> השרת מנהל את כל המידע על המשתמשים המחוברים והקבוצות, והלקוחות שולחים בקשות ועדכונים באופן תקופתי</li>
</ul>

<p>
<strong>סיכום:</strong>
הצילום מדגים איך כל פעולה בממשק הגרפי מתורגמת לפקודה טקסטואלית הנשלחת לשרת, ואיך המערכת מבצעת בדיקות אוטומטיות תקופתיות על מנת להבטיח שהמידע בממשק תמיד מעודכן ומדויק. 
זה מאפשר חוויית משתמש נוחה בממשק הגרפי, תוך שמירה על תקשורת ברורה ואמינה עם השרת ברמת הפרוטוקול.
</p>

<h4>4.4 תקשורת ברשת LAN - מחשב מקומי ומחשב מרוחק</h4>

<p>
<img src="img/toplologyt.png" alt="תקשורת ברשת LAN - מחשב מקומי ומחשב מרוחק">
</p>

<p>
בצילום המסך מוצגת המערכת במצב תפעולי מלא, עם שרת פעיל ושני לקוחות המחוברים מרשת LAN: מחשב מקומי (localhost) ומחשב מרוחק. 
הצילום מדגים את כל שכבות המודל TCP/IP בפעולה - מתקשורת בין מחשבים ברשת המקומית ועד העברת הודעות צ'אט בזמן אמת.
</p>

<p>
<strong>מבנה הרשת:</strong> השרת (0.0.0.0:10000, Status: Running) עם 2 לקוחות מחוברים. לקוח מקומי yaniv (localhost) ולקוח מרוחק ben (192.168.0.x) מנהלים צ'אט דרך השרת, המדגים תקשורת בין מחשבים ברשת LAN.
</p>

<p>
<strong>שכבות TCP/IP בפעולה:</strong> הצילום מדגים את כל שכבות המודל - שכבת היישום (הודעות צ'אט ופקודות), שכבת התעבורה (TCP עם Three-Way Handshake וחיבורים מרובים), שכבת הרשת (IP עם ניתוב בין כתובות שונות), ושכבת הקישור (Ethernet/Wi-Fi ברשת LAN).
תהליך העברת הודעה: ben מקליד "hey" → ההודעה נשלחת דרך TCP/IP לשרת → השרת מנתב ל-yaniv → yaniv מקבל ומציג את ההודעה בממשק.
</p>

<p>
<strong>ממצאים עיקריים מהצילום:</strong>
</p>

<ul>
    <li><strong>תקשורת בין מחשבים שונים ברשת:</strong> המערכת מאפשרת תקשורת בין מחשב מקומי (localhost) ומחשב מרוחק ברשת LAN, מה שמוכיח שהתקשורת עובדת דרך כל שכבות המודל</li>
    <li><strong>השרת כמתווך מרכזי:</strong> השרת מקבל הודעות מכל הלקוחות ומנתב אותן ליעד הנכון, בין אם הלקוח מקומי או מרוחק</li>
    <li><strong>עדכון זמן אמת בממשק השרת:</strong> הממשק הגרפי של השרת מציג את המצב העדכני:
        <ul>
            <li>כל הלקוחות המחוברים מופיעים בוויזואליזציה עם סטטוס שלהם (In chat / Available)</li>
            <li>קווים כתומים מחברים בין לקוחות שנמצאים בצ'אט פעיל</li>
            <li>המידע ב-"Clients Info" מתעדכן בזמן אמת עם מצב כל לקוח והקבוצות שלו</li>
        </ul>
    </li>
    <li><strong>עדכון זמן אמת בממשק הלקוח:</strong> הלקוח מציג את ההודעות שהתקבלו מיידית, מה שמוכיח שהתקשורת עובדת בזמן אמת</li>
    <li><strong>ניהול חיבורים מרובים:</strong> השרת מנהל שני חיבורים במקביל - אחד מהמחשב המקומי ואחד מהמחשב המרוחק, מה שמוכיח את יכולת המערכת לטפל במספר לקוחות</li>
</ul>

<p>
<strong>ויזואליזציה של הרשת:</strong>
</p>

<p>
בממשק השרת ניתן לראות את הויזואליזציה של הרשת:
</p>

<ul>
    <li><strong>צמתים ירוקים (Clients):</strong> לקוחות שנמצאים "In chat" (בצ'אט פעיל) מופיעים כצמתים ירוקים</li>
    <li><strong>קו כתום (Chat connection):</strong> קו כתום מחבר בין לקוחות שנמצאים בצ'אט פעיל ביניהם</li>
    <li><strong>קבוצות:</strong> הקבוצות מוצגות כתיבות סגולות, והחברות בקבוצות מוצגת בקווים מקווקווים סגולים</li>
</ul>

<p>
<strong>סיכום:</strong>
הצילום מדגים את המערכת בפעולה מלאה - שרת פעיל, שני לקוחות מחוברים (מקומי ומרוחק), ותקשורת בזמן אמת בין הלקוחות דרך השרת. 
התקשורת עוברת דרך כל שכבות מודל TCP/IP - משכבת היישום (הודעות צ'אט) דרך שכבת התעבורה (TCP) ושכבת הרשת (IP) ועד שכבת הקישור (LAN). 
זה מוכיח שהמערכת פועלת כמצופה ומקיימת תקשורת אמינה בין מחשבים שונים ברשת המקומית.
</p>

<h4>4.5 קבוצה מאובטחת - ניהול גישה ואבטחת תקשורת</h4>

<p>
<img src="img/wow.png" alt="קבוצה מאובטחת - שלושה לקוחות, קבוצה מאובטחת, ופורץ שלא יכול להיכנס">
</p>

<p>
בצילום המסך מוצג תרחיש של קבוצה מאובטחת עם שלושה לקוחות: yaniv ו-ben (חברים בקבוצה "H.I.T" ונמצאים בצ'אט פעיל) ו-hacker (פורץ פוטנציאלי שלא חבר בקבוצה).
</p>

<p>
<strong>מנגנון האבטחה:</strong> המערכת מבוססת על ניהול הרשאות ברמת השרת. השרת מנהל רשימת חברים לכל קבוצה ומאפשר רק לחברים מורשים לראות ולשלוח הודעות. 
פורץ פוטנציאלי יכול לראות שיש קבוצה ומשתמשים מחוברים, אבל לא יכול לראות את תוכן ההודעות או להיכנס לקבוצה ללא הזמנה.
השרת בודק הרשאות לפני כל פעולה (שליחת/קבלת הודעות) ומגביל גישה רק לחברים בקבוצה.
</p>

<p>
<strong>מגבלות האבטחה:</strong> המערכת מספקת אבטחה ברמת יישום עם ניהול הרשאות, אבל ההודעות נשלחות בטקסט פשוט (ללא הצפנה) וכל אחד יכול להזדהות בכל שם (ללא אימות זהות). 
אפשרויות לשדרוג: הצפנת הודעות (TLS/SSL), אימות זהות, והגנות מתקדמות נוספות.
</p>

<h4>4.6 סיום התקשרות של לקוח - ניתוק חיבור TCP</h4>

<p>
<img src="img/finben.png" alt="סיום התקשרות - Four-Way Handshake של הלקוח ben">
</p>

<p>
בצילום המסך מוצג תהליך סיום החיבור TCP (Connection Teardown) של הלקוח ben מהשרת. 
תהליך זה נקרא "Four-Way Handshake" ומתרחש כאשר אחד הצדדים (במקרה זה השרת) מבקש לסגור את החיבור, או כאשר הלקוח מנתק את החיבור.
</p>

<p>
<strong>ניתוח חבילות התעבורה:</strong>
</p>

<p>
בצילום ניתן לראות את תהליך ה-Four-Way Handshake לסיום החיבור: FIN מהשרת → ACK מהלקוח → FIN מהלקוח → ACK מהשרת. החבילות 24760-24763 מייצגות את תהליך הניתוק.
</p>

<p>
<strong>הסבר קצר על Four-Way Handshake:</strong>
חיבור TCP הוא דו-כיווני, לכן צריך לסגור את שני הכיוונים - כל צד שולח FIN משלו והצד השני מאשר. זה מבטיח שכל הצדדים מודעים לסגירת החיבור ושכל הנתונים נשלחו ונקלטו לפני שהחיבור נסגר לחלוטין.
</p>

<p>
<strong>ממצאים עיקריים:</strong> התהליך מתבצע בצורה מסודרת עם אישורים בכל שלב. כל חבילות ה-FIN והאישורים אינן מכילות נתונים (Len=0), רק דגלי בקרה. הזמנים בין החבילות קצרים (מילישניות), מה שמעיד על רשת מקומית מהירה.
</p>

<p>
<img src="img/finserver.png" alt="ניתוח מפורט של סיום התקשרות - מבט מהצד של השרת">
</p>

<p>
בצילום המסך מוצג ניתוח מפורט של חבילת FIN שנשלחה מהלקוח לשרת, כפי שנלכד ב-Wireshark. 
הצילום מאפשר לראות את כל שכבות המודל TCP/IP בפעולה - משכבת הקישור (Ethernet) ועד שכבת התעבורה (TCP).
</p>

<p>
<strong>ניתוח חבילת FIN (Packet 58715):</strong>
</p>

<p>
החבילה שנבחרה היא Packet 58715 - חבילת FIN+ACK שנשלחה מהלקוח (192.168.0.65:62430) לשרת (192.168.0.137:10000):
</p>

<ul>
    <li><strong>Flags:</strong> [FIN, ACK] - הלקוח מבקש לסגור את החיבור</li>
    <li><strong>Seq=6394, Ack=18994</strong> - מספרי רצף ואישור</li>
    <li><strong>Win=253, Len=0</strong> - חלון תקשורת 253, אין payload</li>
</ul>

<p>
<strong>ניתוח שכבות TCP/IP:</strong> החבילה מדגימה את כל שכבות המודל - Ethernet עם כתובות MAC (Source: 58:20:23:44:8e:f0, Destination: 20:7b:d2:c5:de:6b), IPv4 (Source: 192.168.0.65, Destination: 192.168.0.137), ו-TCP (פורטים 62430→10000, דגלי FIN+ACK). גודל החבילה 60 בתים (מינימלי), ללא payload.
</p>

<p>
<strong>רצף החבילות בתהליך Four-Way Handshake:</strong> FIN מהלקוח → ACK מהשרת → FIN מהשרת → ACK מהלקוח, מה שסוגר את החיבור במלואו. בהשוואה לתמונה הקודמת, כאן הלקוח יוזם את הניתוק במקום השרת, אך התהליך זהה.
</p>

<p>
<strong>סיכום:</strong>
הצילום מדגים את כל שכבות מודל TCP/IP בפעולה - משכבת הקישור (Ethernet עם כתובות MAC) דרך שכבת הרשת (IP עם כתובות IP) ועד שכבת התעבורה (TCP עם פורטים ודגלים). 
החבילה מדגימה תהליך סיום חיבור נקי ומסודר, כאשר הלקוח יוזם את הניתוק והשרת מגיב בהתאם. 
זה מוכיח שהמערכת מטפלת נכון בניתוקים יזומים מכל צד, ושומרת על אמינות הפרוטוקול TCP גם בסיום החיבור.
</p>

<h2>חלק 3 – שימוש בבינה מלאכותית במהלך העבודה</h2>

<p>
במהלך העבודה על הפרויקט נעשה שימוש מוגבל ומבוקר בבינה מלאכותית, בהתאם להנחיות הקורס.
</p>

<h3>1. מטרות השימוש בבינה מלאכותית</h3>

<p>
השימוש בבינה מלאכותית נעשה לצרכים הבאים:
</p>

<ul>
    <li>יצירת נתוני דוגמה המדמים תעבורת רשת (DHCP) לצורך בניית קובץ CSV.</li>
    <li>סיוע בניסוח הסברים טכניים וטקסטואליים לדוח (הבהרת מושגים, קיצור ניסוחים).</li>
    <li>בדיקה והבנה של פלטים מ-Frame, IP, TCP ב-Wireshark לצורך ניתוח נכון.</li>
</ul>

<p>
הבינה המלאכותית לא שימשה לכתיבת קוד מלא, לא לביצוע הלכידה עצמה, ולא לניתוח אוטומטי של תעבורת הרשת.
</p>

<h3>2. דוגמאות לשאלות שנשאלו במהלך העבודה:</h3>

<ol>
    <li>יצירת נתוני דוגמה: נעזרתי בבינה מלאכותית ליצירת קובץ CSV המכיל הודעות DHCP אמיתיות, כולל תהליכי Discover, Offer, Request ו-ACK, על מנת לקבל דוגמאות אותנטיות של תעבורת רשת.</li>
    <li>הבנת דגלי TCP: כשנתקלתי בדגלים PSH ו-ACK ב-Wireshark, ביקשתי הסבר קצר על משמעותם והשימוש שלהם בפרוטוקול TCP.</li>
    <li>ניסוח הסיכומים: בכמה מקומות ביקשתי עזרה בניסוח סיכומים לניתוח שכבות TCP/IP כך שיהיו ברורים ונוחים לקריאה בדוח האקדמי.</li>
    <li>אימות ידע טכני: לפני כתיבת החלק על Loopback, ביקשתי לוודא שההבנה שלי לגבי השימוש בכתובת 127.0.0.1 נכונה מבחינה טכנית.</li>
    <li>פשט ניסוחים טכניים: במקרים שבהם הניסוח הטכני היה מסובך מדי, ביקשתי לפשט אותו כך שיתאים לרמה של דוח סטודנטיאלי תוך שמירה על דיוק טכני.</li>
</ol>

<h2>סיכום</h2>

<div class="summary">
<p>
הפרויקט הציג יישום מלא של תקשורת TCP/IP בשני חלקים עיקריים:
</p>

<ul>
    <li><strong>חלק 1:</strong> הדמיית תהליך האריזה של חבילות נתונים בשכבות מודל TCP/IP, יצירת קובץ CSV עם הודעות DHCP, יצירת חבילות TCP/IP באמצעות Scapy, ולכידת התעבורה ב-Wireshark לניתוח מעמיק.</li>
    <li><strong>חלק 2:</strong> פיתוח מעשי של שרת ולקוח TCP/IP עם תכנות מולטי-תרדי, ממשק גרפי, מערכת לוגים, וניתוח תעבורה עד שכבת הרשת.</li>
</ul>

<p>
הפרויקט מספק הבנה מעמיקה של מודל TCP/IP, תהליך האריזה, תכנות תקשורת, וטכנולוגיות מתקדמות כמו תכנות אסינכרוני וממשקים גרפיים. כל הדרישות מולאו בהצלחה, והקוד הוא מקצועי, מתועד היטב, ומוכן לשימוש.
</p>
</div>

</body>
</html>

